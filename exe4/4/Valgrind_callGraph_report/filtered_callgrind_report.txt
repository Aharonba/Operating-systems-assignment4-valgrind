--------------------------------------------------------------------------------
Profile data file 'callgrind.out.91803' (creator: callgrind-3.18.1)
--------------------------------------------------------------------------------
I1 cache: 
D1 cache: 
LL cache: 
Timerange: Basic block 0 - 476350
Trigger: Program termination
Profiled target:  ./demo -v 10 -e 12 -s 42 (PID 91803, part 1)
Events recorded:  Ir
Events shown:     Ir
Event sort order: Ir
Thresholds:       99
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                 
--------------------------------------------------------------------------------
2,422,715 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                file:function
--------------------------------------------------------------------------------
 63,274 ( 2.61%)  ./elf/../sysdeps/aarch64/dl-machine.h:_dl_lookup_symbol_x'2
 48,102 ( 1.99%)  ???:gcov_do_dump'2 [/home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/demo]
 36,609 ( 1.51%)  ???:gcov_write_words'2 [/home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/demo]
 13,778 ( 0.57%)  ./elf/../sysdeps/generic/ldsodefs.h:do_lookup_x'2
 13,436 ( 0.55%)  ???:gcov_write_words [/home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/demo]
 12,412 ( 0.51%)  ./elf/../sysdeps/generic/ldsodefs.h:_dl_relocate_object'2
 11,439 ( 0.47%)  ./gmon/../sysdeps/aarch64/sysdep.h:_mcount@@GLIBC_2.18'2
 10,261 ( 0.42%)  /usr/include/c++/11/bits/hashtable_policy.h:_mcount@@GLIBC_2.18'2
  9,894 ( 0.41%)  ???:gcov_do_dump [/home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/demo]
  9,205 ( 0.38%)  /usr/include/c++/11/bits/stl_bvector.h:_mcount@@GLIBC_2.18'2
  6,314 ( 0.26%)  /usr/include/c++/11/bits/stl_list.h:_mcount@@GLIBC_2.18'2
  4,458 ( 0.18%)  ./elf/../sysdeps/generic/dl-protected.h:do_lookup_x'2
  3,596 ( 0.15%)  /usr/include/c++/11/bits/hashtable.h:_mcount@@GLIBC_2.18'2
  3,553 ( 0.15%)  /usr/include/c++/11/ext/aligned_buffer.h:_mcount@@GLIBC_2.18'2
  3,209 ( 0.13%)  /usr/include/c++/11/bits/move.h:_mcount@@GLIBC_2.18'2
  2,252 ( 0.09%)  ./elf/./elf/dl-runtime.c:_dl_lookup_symbol_x
  2,124 ( 0.09%)  ./elf/./elf/do-rel.h:_dl_lookup_symbol_x'2
  1,438 ( 0.06%)  /usr/include/c++/11/bits/alloc_traits.h:_mcount@@GLIBC_2.18'2
  1,180 ( 0.05%)  /usr/include/c++/11/tuple:_mcount@@GLIBC_2.18'2
  1,152 ( 0.05%)  ./wcsmbs/./wcsmbsload.h:btowc
  1,128 ( 0.05%)  ./elf/../sysdeps/aarch64/dl-trampoline.S:_dl_fixup
    914 ( 0.04%)  ???:malloc
    893 ( 0.04%)  /usr/include/c++/11/utility:_mcount@@GLIBC_2.18'2
    854 ( 0.04%)  ???:__cxa_finalize
    840 ( 0.03%)  /usr/include/c++/11/bits/allocated_ptr.h:_mcount@@GLIBC_2.18'2
    608 ( 0.03%)  /usr/include/c++/11/bits/stl_function.h:_mcount@@GLIBC_2.18'2
    570 ( 0.02%)  /usr/include/c++/11/bits/functional_hash.h:_mcount@@GLIBC_2.18'2
    528 ( 0.02%)  main.cpp:Graph::addEdge(int, int)'2
    523 ( 0.02%)  ./malloc/./malloc/malloc.c:ptmalloc_init.part.0
    512 ( 0.02%)  ./iconv/./iconv/gconv_simple.c:btowc
    498 ( 0.02%)  /usr/include/c++/11/bits/unordered_map.h:_mcount@@GLIBC_2.18'2
    442 ( 0.02%)  /usr/include/c++/11/new:operator new(unsigned long, void*) [/home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/demo]
    440 ( 0.02%)  /usr/include/c++/11/new:_mcount@@GLIBC_2.18'2
    426 ( 0.02%)  ./elf/./elf/dl-deps.c:_dl_catch_exception'2
    405 ( 0.02%)  ./elf/./elf/get-dynamic-info.h:_dl_new_object'2
    334 ( 0.01%)  Graph.hpp:_mcount@@GLIBC_2.18'2
    330 ( 0.01%)  ./elf/./elf/dl-load.c:_dl_new_object'2
    279 ( 0.01%)  main.cpp:generateRandomGraph(Graph*, int, int)'2 [/home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/demo]
    209 ( 0.01%)  /usr/include/c++/11/bits/ptr_traits.h:_mcount@@GLIBC_2.18'2
    201 ( 0.01%)  ./libio/./libio/libioP.h:_IO_default_xsputn'2
    200 ( 0.01%)  ./libio/./libio/libioP.h:fflush
    173 ( 0.01%)  ./elf/../sysdeps/aarch64/dl-machine.h:_dl_start'2
    171 ( 0.01%)  ./elf/../sysdeps/aarch64/dl-machine.h:_dl_lookup_symbol_x
    156 ( 0.01%)  ./malloc/./malloc/arena.c:free
    155 ( 0.01%)  ./elf/./elf/dl-fini.c:pthread_mutex_lock@@GLIBC_2.17
    154 ( 0.01%)  Graph.hpp:Graph::addEdge(int, int)'2 [/home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/demo]
    150 ( 0.01%)  ./elf/./elf/dl-hwcaps.c:_dl_hwcaps_split_masked'2
    130 ( 0.01%)  /usr/include/c++/11/new:operator new(unsigned long, void*)'2 [/home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/demo]
    120 ( 0.00%)  ./elf/../sysdeps/posix/dl-fileid.h:_dl_map_object_from_fd

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/hashtable.h
--------------------------------------------------------------------------------
Ir             

-- line 294 ----------------------------------------
    .                 struct _Scoped_node
    .                 {
    .           	// Take ownership of a node with a constructed element.
    .           	_Scoped_node(__node_ptr __n, __hashtable_alloc* __h)
    .           	: _M_h(__h), _M_node(__n) { }
    .           
    .           	// Allocate a node and construct an element within it.
    .           	template<typename... _Args>
  250 ( 0.01%)  	  _Scoped_node(__hashtable_alloc* __h, _Args&&... __args)
44,352 ( 1.83%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
   30 ( 0.00%)  	  : _M_h(__h),
   50 ( 0.00%)  	  { }
    .           
    .           	// Destroy element and deallocate node.
  260 ( 0.01%)  	~_Scoped_node() { if (_M_node) _M_h->_M_deallocate_node(_M_node); };
  692 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
    .           
    .           	_Scoped_node(const _Scoped_node&) = delete;
    .           	_Scoped_node& operator=(const _Scoped_node&) = delete;
    .           
    .           	__hashtable_alloc* _M_h;
    .           	__node_ptr _M_node;
    .                 };
    .           
-- line 316 ----------------------------------------
-- line 413 ----------------------------------------
    .                 void
    .                 _M_update_bbegin(__node_ptr __n)
    .                 {
    .           	_M_before_begin._M_nxt = __n;
    .           	_M_update_bbegin();
    .                 }
    .           
    .                 bool
   40 ( 0.00%)        _M_uses_single_bucket(__buckets_ptr __bkts) const
  150 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
   24 ( 0.00%)        { return __builtin_expect(__bkts == &_M_single_bucket, false); }
    .           
    .                 bool
    .                 _M_uses_single_bucket() const
    .                 { return _M_uses_single_bucket(_M_buckets); }
    .           
    .                 __hashtable_alloc&
    .                 _M_base_alloc() { return *this; }
    .           
    .                 __buckets_ptr
   20 ( 0.00%)        _M_allocate_buckets(size_type __bkt_count)
1,358 ( 0.06%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .                 {
    7 ( 0.00%)  	if (__builtin_expect(__bkt_count == 1, false))
    .           	  {
    .           	    _M_single_bucket = nullptr;
    .           	    return &_M_single_bucket;
    .           	  }
    .           
   11 ( 0.00%)  	return __hashtable_alloc::_M_allocate_buckets(__bkt_count);
    2 ( 0.00%)        }
    .           
    .                 void
   42 ( 0.00%)        _M_deallocate_buckets(__buckets_ptr __bkts, size_type __bkt_count)
1,552 ( 0.06%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
    .                 {
   33 ( 0.00%)  	if (_M_uses_single_bucket(__bkts))
    1 ( 0.00%)  	  return;
    .           
   11 ( 0.00%)  	__hashtable_alloc::_M_deallocate_buckets(__bkts, __bkt_count);
    4 ( 0.00%)        }
    .           
    .                 void
   38 ( 0.00%)        _M_deallocate_buckets()
1,742 ( 0.07%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
   34 ( 0.00%)        { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }
    .           
    .                 // Gets bucket begin, deals with the fact that non-empty buckets contain
    .                 // their before begin node.
    .                 __node_ptr
    .                 _M_bucket_begin(size_type __bkt) const;
    .           
    .                 __node_ptr
   38 ( 0.00%)        _M_begin() const
  136 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
    8 ( 0.00%)        { return static_cast<__node_ptr>(_M_before_begin._M_nxt); }
    .           
    .                 // Assign *this using another _Hashtable instance. Whether elements
    .                 // are copied or moved depends on the _Ht reference.
    .                 template<typename _Ht>
    .           	void
    .           	_M_assign_elements(_Ht&&);
    .           
    .                 template<typename _Ht, typename _NodeGenerator>
-- line 471 ----------------------------------------
-- line 520 ----------------------------------------
    .                 template<typename _InputIterator>
    .           	_Hashtable(_InputIterator __first, _InputIterator __last,
    .           		   size_type __bkt_count_hint,
    .           		   false_type __uks);
    .           
    .               public:
    .                 // Constructor, destructor, assignment, swap
   72 ( 0.00%)        _Hashtable() = default;
    .           
    .                 _Hashtable(const _Hashtable&);
    .           
    .           
    .                 explicit
    .                 _Hashtable(size_type __bkt_count_hint,
    .           		 const _Hash& __hf = _Hash(),
-- line 536 ----------------------------------------
-- line 782 ----------------------------------------
    .           	       typename = __has_is_transparent_t<_Equal, _Kt>>
    .           	pair<const_iterator, const_iterator>
    .           	_M_equal_range_tr(const _Kt& __k) const;
    .           #endif // C++20
    .           
    .               private:
    .                 // Bucket index computation helpers.
    .                 size_type
  180 ( 0.01%)        _M_bucket_index(const __node_value_type& __n) const noexcept
11,976 ( 0.49%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (9x)
  162 ( 0.01%)        { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }
    .           
    .                 size_type
  980 ( 0.04%)        _M_bucket_index(__hash_code __c) const
12,918 ( 0.53%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (48x)
  882 ( 0.04%)        { return __hash_code_base::_M_bucket_index(__c, _M_bucket_count); }
    .           
    .                 // Find and insert helper functions and types
    .                 // Find the node before the one matching the criteria.
    .                 __node_base_ptr
    .                 _M_find_before_node(size_type, const key_type&, __hash_code) const;
    .           
    .                 template<typename _Kt>
    .           	__node_base_ptr
    .           	_M_find_before_node_tr(size_type, const _Kt&, __hash_code) const;
    .           
    .                 __node_ptr
1,056 ( 0.04%)        _M_find_node(size_type __bkt, const key_type& __key,
54,306 ( 2.24%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (48x)
    .           		   __hash_code __c) const
    .                 {
  672 ( 0.03%)  	__node_base_ptr __before_n = _M_find_before_node(__bkt, __key, __c);
  144 ( 0.01%)  	if (__before_n)
  380 ( 0.02%)  	  return static_cast<__node_ptr>(__before_n->_M_nxt);
   10 ( 0.00%)  	return nullptr;
  144 ( 0.01%)        }
    .           
    .                 template<typename _Kt>
    .           	__node_ptr
    .           	_M_find_node_tr(size_type __bkt, const _Kt& __key,
    .           			__hash_code __c) const
    .           	{
    .           	  auto __before_n = _M_find_before_node_tr(__bkt, __key, __c);
    .           	  if (__before_n)
-- line 822 ----------------------------------------
-- line 1520 ----------------------------------------
    .           	  __ht.clear();
    .           	}
    .               }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
   19 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
47,723 ( 1.97%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    .               ~_Hashtable() noexcept
    .               {
    9 ( 0.00%)        clear();
    9 ( 0.00%)        _M_deallocate_buckets();
   12 ( 0.00%)      }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               void
    .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1542 ----------------------------------------
-- line 1819 ----------------------------------------
    .           
    .             // Find the node before the one whose key compares equal to k in the bucket
    .             // bkt. Return nullptr if no node is found.
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               auto
1,056 ( 0.04%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
49,258 ( 2.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (48x)
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    .               _M_find_before_node(size_type __bkt, const key_type& __k,
    .           			__hash_code __code) const
    .               -> __node_base_ptr
    .               {
  336 ( 0.01%)        __node_base_ptr __prev_p = _M_buckets[__bkt];
  214 ( 0.01%)        if (!__prev_p)
   20 ( 0.00%)  	return nullptr;
    .           
  114 ( 0.00%)        for (__node_ptr __p = static_cast<__node_ptr>(__prev_p->_M_nxt);;
    .           	   __p = __p->_M_next())
    .           	{
  646 ( 0.03%)  	  if (this->_M_equals(__k, __code, *__p))
  342 ( 0.01%)  	    return __prev_p;
    .           
    .           	  if (!__p->_M_nxt || _M_bucket_index(*__p->_M_next()) != __bkt)
    .           	    break;
    .           	  __prev_p = __p;
    .           	}
    .           
    .                 return nullptr;
   96 ( 0.00%)      }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               template<typename _Kt>
    .                 auto
    .                 _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
-- line 1857 ----------------------------------------
-- line 1878 ----------------------------------------
    .           	return nullptr;
    .                 }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               void
  220 ( 0.01%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
14,042 ( 0.58%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    .               _M_insert_bucket_begin(size_type __bkt, __node_ptr __node)
    .               {
   80 ( 0.00%)        if (_M_buckets[__bkt])
    .           	{
    .           	  // Bucket is not empty, we just need to insert the new node
    .           	  // after the bucket before begin.
    .           	  __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
    .           	  _M_buckets[__bkt]->_M_nxt = __node;
    .           	}
    .                 else
    .           	{
    .           	  // The bucket is empty, the new node is inserted at the
    .           	  // beginning of the singly-linked list and the bucket will
    .           	  // contain _M_before_begin pointer.
   40 ( 0.00%)  	  __node->_M_nxt = _M_before_begin._M_nxt;
   30 ( 0.00%)  	  _M_before_begin._M_nxt = __node;
    .           
  103 ( 0.00%)  	  if (__node->_M_nxt)
    .           	    // We must update former begin bucket that is pointing to
    .           	    // _M_before_begin.
  180 ( 0.01%)  	    _M_buckets[_M_bucket_index(*__node->_M_next())] = __node;
    .           
  150 ( 0.01%)  	  _M_buckets[__bkt] = &_M_before_begin;
    .           	}
   40 ( 0.00%)      }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               void
    .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 1920 ----------------------------------------
-- line 2000 ----------------------------------------
    .           	return __pos;
    .                 }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               auto
  280 ( 0.01%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
22,180 ( 0.92%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    .               _M_insert_unique_node(size_type __bkt, __hash_code __code,
    .           			  __node_ptr __node, size_type __n_elt)
    .               -> iterator
    .               {
  140 ( 0.01%)        const __rehash_state& __saved_state = _M_rehash_policy._M_state();
  301 ( 0.01%)  	= _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count,
    .           					  __n_elt);
    .           
   10 ( 0.00%)        if (__do_rehash.first)
    .           	{
   13 ( 0.00%)  	  _M_rehash(__do_rehash.second, __saved_state);
   12 ( 0.00%)  	  __bkt = _M_bucket_index(__code);
    .           	}
    .           
   76 ( 0.00%)        this->_M_store_code(*__node, __code);
    .           
    .                 // Always insert at the beginning of the bucket.
  110 ( 0.00%)        _M_insert_bucket_begin(__bkt, __node);
   50 ( 0.00%)        ++_M_element_count;
  120 ( 0.00%)        return iterator(__node);
  100 ( 0.00%)      }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               auto
    .               _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
-- line 2039 ----------------------------------------
-- line 2308 ----------------------------------------
    .                 return iterator(__n);
    .               }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               void
   19 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
45,791 ( 1.89%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    .               clear() noexcept
    .               {
   20 ( 0.00%)        this->_M_deallocate_nodes(_M_begin());
   19 ( 0.00%)        __builtin_memset(_M_buckets, 0,
   21 ( 0.00%)  => ./string/../sysdeps/aarch64/memset.S:__GI_memset (1x)
    2 ( 0.00%)  		       _M_bucket_count * sizeof(__node_base_ptr));
    .                 _M_element_count = 0;
    .                 _M_before_begin._M_nxt = nullptr;
    .               }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
-- line 2330 ----------------------------------------
-- line 2347 ----------------------------------------
    .           	_M_rehash_policy._M_reset(__saved_state);
    .               }
    .           
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               void
   22 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
1,938 ( 0.08%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    .               _M_rehash(size_type __bkt_count, const __rehash_state& __state)
    .               {
    .                 __try
    .           	{
   11 ( 0.00%)  	  _M_rehash_aux(__bkt_count, __unique_keys{});
    .           	}
    .                 __catch(...)
    .           	{
    .           	  // A failure here means that buckets allocation failed.  We only
    .           	  // have to restore hash policy previous state.
    .           	  _M_rehash_policy._M_reset(__state);
    .           	  __throw_exception_again;
    .           	}
    4 ( 0.00%)      }
    .           
    .             // Rehash when there is no equivalent elements.
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               void
   21 ( 0.00%)      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
1,845 ( 0.08%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .           	       _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>::
    .               _M_rehash_aux(size_type __bkt_count, true_type /* __uks */)
    .               {
   12 ( 0.00%)        __buckets_ptr __new_buckets = _M_allocate_buckets(__bkt_count);
    3 ( 0.00%)        __node_ptr __p = _M_begin();
    2 ( 0.00%)        _M_before_begin._M_nxt = nullptr;
   11 ( 0.00%)        while (__p)
    .           	{
    .           	  __node_ptr __next = __p->_M_next();
    .           	    = __hash_code_base::_M_bucket_index(*__p, __bkt_count);
    .           	  if (!__new_buckets[__bkt])
    .           	    {
    .           	      __p->_M_nxt = _M_before_begin._M_nxt;
    .           	      _M_before_begin._M_nxt = __p;
-- line 2394 ----------------------------------------
-- line 2401 ----------------------------------------
    .           	    {
    .           	      __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    .           	      __new_buckets[__bkt]->_M_nxt = __p;
    .           	    }
    .           
    .           	  __p = __next;
    .           	}
    .           
    9 ( 0.00%)        _M_deallocate_buckets();
    3 ( 0.00%)        _M_bucket_count = __bkt_count;
    3 ( 0.00%)        _M_buckets = __new_buckets;
    3 ( 0.00%)      }
    .           
    .             // Rehash when there can be equivalent elements, preserve their relative
    .             // order.
    .             template<typename _Key, typename _Value, typename _Alloc,
    .           	   typename _ExtractKey, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               void
-- line 2420 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/list.tcc
--------------------------------------------------------------------------------
Ir           

-- line 58 ----------------------------------------
  .           
  .           namespace std _GLIBCXX_VISIBILITY(default)
  .           {
  .           _GLIBCXX_BEGIN_NAMESPACE_VERSION
  .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
  .           
  .             template<typename _Tp, typename _Alloc>
  .               void
190 ( 0.01%)      _List_base<_Tp, _Alloc>::
23,664 ( 0.98%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .               _M_clear() _GLIBCXX_NOEXCEPT
  .               {
  .                 typedef _List_node<_Tp>  _Node;
 30 ( 0.00%)        __detail::_List_node_base* __cur = _M_impl._M_node._M_next;
384 ( 0.02%)        while (__cur != &_M_impl._M_node)
  .           	{
 48 ( 0.00%)  	  _Node* __tmp = static_cast<_Node*>(__cur);
 72 ( 0.00%)  	  __cur = __tmp->_M_next;
240 ( 0.01%)  	  _Tp* __val = __tmp->_M_valptr();
  .           #if __cplusplus >= 201103L
  .           #else
  .           #endif
 72 ( 0.00%)  	  _M_put_node(__tmp);
  .           	}
 30 ( 0.00%)      }
  .           
  .           #if __cplusplus >= 201103L
  .             template<typename _Tp, typename _Alloc>
  .               template<typename... _Args>
  .                 typename list<_Tp, _Alloc>::iterator
  .                 list<_Tp, _Alloc>::
  .                 emplace(const_iterator __position, _Args&&... __args)
  .                 {
-- line 91 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_list.h
--------------------------------------------------------------------------------
Ir             

-- line 102 ----------------------------------------
    .           
    .               /// The %list node header.
    .               struct _List_node_header : public _List_node_base
    .               {
    .           #if _GLIBCXX_USE_CXX11_ABI
    .           #endif
    .           
  190 ( 0.01%)        _List_node_header() _GLIBCXX_NOEXCEPT
1,604 ( 0.07%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  120 ( 0.00%)        { _M_init(); }
    .           
    .           #if __cplusplus >= 201103L
    .                 _List_node_header(_List_node_header&& __x) noexcept
    .                 : _List_node_base{ __x._M_next, __x._M_prev }
    .           # if _GLIBCXX_USE_CXX11_ABI
    .                 , _M_size(__x._M_size)
    .           # endif
    .                 {
-- line 119 ----------------------------------------
-- line 142 ----------------------------------------
    .           	    _M_size = __x._M_size;
    .           # endif
    .           	    __x._M_init();
    .           	  }
    .                 }
    .           #endif
    .           
    .                 void
  190 ( 0.01%)        _M_init() _GLIBCXX_NOEXCEPT
  742 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
    .                 {
   70 ( 0.00%)  	this->_M_next = this->_M_prev = this;
    .           #if _GLIBCXX_USE_CXX11_ABI
   20 ( 0.00%)  	this->_M_size = 0;
    .           #endif
   30 ( 0.00%)        }
    .           
    .               private:
    .                 _List_node_base* _M_base() { return this; }
    .               };
    .             } // namespace detail
    .           
    .           _GLIBCXX_BEGIN_NAMESPACE_CONTAINER
    .           
    .             /// An actual node in the %list.
    .             template<typename _Tp>
    .               struct _List_node : public __detail::_List_node_base
    .               {
    .           #if __cplusplus >= 201103L
2,448 ( 0.10%)        _Tp*       _M_valptr()       { return _M_storage._M_ptr(); }
    .                 _Tp const* _M_valptr() const { return _M_storage._M_ptr(); }
    .           #else
    .                 _Tp _M_data;
    .           #endif
    .               };
    .           
-- line 179 ----------------------------------------
-- line 193 ----------------------------------------
    .                 typedef _Tp				value_type;
    .                 typedef _Tp*				pointer;
    .                 typedef _Tp&				reference;
    .           
    .                 _List_iterator() _GLIBCXX_NOEXCEPT
    .                 : _M_node() { }
    .           
    .                 explicit
  880 ( 0.04%)        _List_iterator(__detail::_List_node_base* __x) _GLIBCXX_NOEXCEPT
2,996 ( 0.12%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (44x)
  264 ( 0.01%)        : _M_node(__x) { }
    .           
    .                 _Self
    .                 _M_const_cast() const _GLIBCXX_NOEXCEPT
    .                 { return *this; }
    .           
    .                 // Must downcast from _List_node_base to _List_node to get to value.
    .                 reference
  456 ( 0.02%)        operator*() const _GLIBCXX_NOEXCEPT
  335 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
  360 ( 0.01%)        { return *static_cast<_Node*>(_M_node)->_M_valptr(); }
    .           
    .                 pointer
    .                 operator->() const _GLIBCXX_NOEXCEPT
    .                 { return static_cast<_Node*>(_M_node)->_M_valptr(); }
    .           
    .                 _Self&
  456 ( 0.02%)        operator++() _GLIBCXX_NOEXCEPT
  142 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
    .                 {
  120 ( 0.00%)  	_M_node = _M_node->_M_next;
   24 ( 0.00%)  	return *this;
   48 ( 0.00%)        }
    .           
    .                 _Self
    .                 operator++(int) _GLIBCXX_NOEXCEPT
    .                 {
    .           	_Self __tmp = *this;
    .           	_M_node = _M_node->_M_next;
    .           	return __tmp;
    .                 }
-- line 230 ----------------------------------------
-- line 245 ----------------------------------------
    .                 }
    .           
    .                 friend bool
    .                 operator==(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
    .                 { return __x._M_node == __y._M_node; }
    .           
    .           #if __cpp_impl_three_way_comparison < 201907L
    .                 friend bool
  680 ( 0.03%)        operator!=(const _Self& __x, const _Self& __y) _GLIBCXX_NOEXCEPT
   73 ( 0.00%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
  306 ( 0.01%)        { return __x._M_node != __y._M_node; }
    .           #endif
    .           
    .                 // The only member points to the %list element.
    .                 __detail::_List_node_base* _M_node;
    .               };
    .           
    .             /**
    .              *  @brief A list::const_iterator.
-- line 262 ----------------------------------------
-- line 367 ----------------------------------------
    .           	  {
    .           	    __first = __first->_M_next;
    .           	    ++__n;
    .           	  }
    .           	return __n;
    .                 }
    .           #endif
    .           
  310 ( 0.01%)        struct _List_impl
    .                 : public _Node_alloc_type
    .                 {
    .           	__detail::_List_node_header _M_node;
    .           
  190 ( 0.01%)  	_List_impl() _GLIBCXX_NOEXCEPT_IF(
4,190 ( 0.17%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
    .           	    is_nothrow_default_constructible<_Node_alloc_type>::value)
  180 ( 0.01%)  	: _Node_alloc_type()
   30 ( 0.00%)  	{ }
    .           
    .           	_List_impl(const _Node_alloc_type& __a) _GLIBCXX_NOEXCEPT
    .           	: _Node_alloc_type(__a)
    .           	{ }
    .           
    .           #if __cplusplus >= 201103L
    .           	_List_impl(_List_impl&&) = default;
    .           
-- line 391 ----------------------------------------
-- line 397 ----------------------------------------
    .           	{ }
    .           #endif
    .                 };
    .           
    .                 _List_impl _M_impl;
    .           
    .           #if _GLIBCXX_USE_CXX11_ABI
   69 ( 0.00%)        size_t _M_get_size() const { return _M_impl._M_node._M_size; }
  200 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (3x)
    .           
    .                 void _M_set_size(size_t __n) { _M_impl._M_node._M_size = __n; }
    .           
  696 ( 0.03%)        void _M_inc_size(size_t __n) { _M_impl._M_node._M_size += __n; }
1,706 ( 0.07%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
    .           
    .                 void _M_dec_size(size_t __n) { _M_impl._M_node._M_size -= __n; }
    .           
    .           # if !_GLIBCXX_INLINE_VERSION
    .                 size_t
    .                 _M_distance(const __detail::_List_node_base* __first,
    .           		  const __detail::_List_node_base* __last) const
    .                 { return _S_distance(__first, __last); }
-- line 417 ----------------------------------------
-- line 434 ----------------------------------------
    .                 {
    .           	return _S_distance(_M_impl._M_node._M_next,
    .                 }
    .           # endif
    .           #endif
    .           
    .                 typename _Node_alloc_traits::pointer
  456 ( 0.02%)        _M_get_node()
14,096 ( 0.58%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
  336 ( 0.01%)        { return _Node_alloc_traits::allocate(_M_impl, 1); }
    .           
    .                 void
  480 ( 0.02%)        _M_put_node(typename _Node_alloc_traits::pointer __p) _GLIBCXX_NOEXCEPT
3,948 ( 0.16%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  336 ( 0.01%)        { _Node_alloc_traits::deallocate(_M_impl, __p, 1); }
    .           
    .             public:
    .           
    .                 _Node_alloc_type&
2,214 ( 0.09%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (34x)
  144 ( 0.01%)        { return _M_impl; }
    .           
    .                 const _Node_alloc_type&
    .                 { return _M_impl; }
    .           
    .           #if __cplusplus >= 201103L
  310 ( 0.01%)        _List_base() = default;
    .           #else
    .                 _List_base() { }
    .           #endif
    .           
    .                 _List_base(const _Node_alloc_type& __a) _GLIBCXX_NOEXCEPT
    .                 : _M_impl(__a)
    .                 { }
    .           
-- line 469 ----------------------------------------
-- line 491 ----------------------------------------
    .                 { }
    .           
    .                 void
    .                 _M_move_nodes(_List_base&& __x)
    .           #endif
    .           
    .                 // This is what actually destroys the list.
  190 ( 0.01%)        ~_List_base() _GLIBCXX_NOEXCEPT
27,112 ( 1.12%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  210 ( 0.01%)        { _M_clear(); }
    .           
    .                 void
    .                 _M_clear() _GLIBCXX_NOEXCEPT;
    .           
    .                 void
    .                 _M_init() _GLIBCXX_NOEXCEPT
    .                 { this->_M_impl._M_node._M_init(); }
    .               };
-- line 508 ----------------------------------------
-- line 625 ----------------------------------------
    .           	    _M_put_node(__p);
    .           	    __throw_exception_again;
    .           	  }
    .           	return __p;
    .                 }
    .           #else
    .                 template<typename... _Args>
    .           	_Node*
  624 ( 0.03%)  	_M_create_node(_Args&&... __args)
46,502 ( 1.92%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
    .           	{
  264 ( 0.01%)  	  auto __p = this->_M_get_node();
  264 ( 0.01%)  	  __allocated_ptr<_Node_alloc_type> __guard{__alloc, __p};
  720 ( 0.03%)  	  _Node_alloc_traits::construct(__alloc, __p->_M_valptr(),
  240 ( 0.01%)  	  __guard = nullptr;
   48 ( 0.00%)  	  return __p;
  480 ( 0.02%)  	}
    .           #endif
    .           
    .           #if _GLIBCXX_USE_CXX11_ABI
    .                 static size_t
    .                 _S_distance(const_iterator __first, const_iterator __last)
    .           
    .                 // return the stored size
    .                 size_t
   57 ( 0.00%)        _M_node_count() const
  466 ( 0.02%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (3x)
   42 ( 0.00%)        { return this->_M_get_size(); }
    .           #else
    .                 // dummy implementations used when the size is not stored
    .                 static size_t
    .                 _S_distance(const_iterator, const_iterator)
    .                 { return 0; }
    .           
    .                 // count the number of nodes
    .                 size_t
-- line 661 ----------------------------------------
-- line 666 ----------------------------------------
    .               public:
    .                 // [23.2.2.1] construct/copy/destroy
    .           
    .                 /**
    .                  *  @brief  Creates a %list with no elements.
    .                  */
    .           #if __cplusplus >= 201103L
  310 ( 0.01%)        list() = default;
    .           #else
    .                 list() { }
    .           #endif
    .           
    .                 /**
    .                  *  @brief  Creates a %list with no elements.
    .                  */
-- line 682 ----------------------------------------
-- line 820 ----------------------------------------
    .           #if __cplusplus >= 201103L
    .                 /**
    .                  *  No explicit dtor needed as the _Base dtor takes care of
    .                  *  things.  The _Base dtor only erases the elements, and note
    .                  *  that if the elements themselves are pointers, the pointed-to
    .                  *  memory is not touched in any way.  Managing the pointer is
    .                  *  the user's responsibility.
    .                  */
  310 ( 0.01%)        ~list() = default;
    .           #endif
    .           
    .                 /**
    .                  *  @brief  %List assignment operator.
    .                  *
    .                  *  All the elements of @a __x are copied.
    .                  *
-- line 836 ----------------------------------------
-- line 938 ----------------------------------------
    .           
    .                 // iterators
    .                 /**
    .                  *  Returns a read/write iterator that points to the first element in the
    .                  *  %list.  Iteration is done in ordinary element order.
    .                  */
    .                 iterator
  240 ( 0.01%)        begin() _GLIBCXX_NOEXCEPT
  175 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
  230 ( 0.01%)        { return iterator(this->_M_impl._M_node._M_next); }
    .           
    .                 /**
    .                  *  Returns a read-only (constant) iterator that points to the
    .                  *  first element in the %list.  Iteration is done in ordinary
    .                  *  element order.
    .                  */
    .                 const_iterator
    .                 begin() const _GLIBCXX_NOEXCEPT
-- line 955 ----------------------------------------
-- line 956 ----------------------------------------
    .                 { return const_iterator(this->_M_impl._M_node._M_next); }
    .           
    .                 /**
    .                  *  Returns a read/write iterator that points one past the last
    .                  *  element in the %list.  Iteration is done in ordinary element
    .                  *  order.
    .                  */
    .                 iterator
  816 ( 0.03%)        end() _GLIBCXX_NOEXCEPT
4,256 ( 0.18%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (25x)
  748 ( 0.03%)        { return iterator(&this->_M_impl._M_node); }
    .           
    .                 /**
    .                  *  Returns a read-only (constant) iterator that points one past
    .                  *  the last element in the %list.  Iteration is done in ordinary
    .                  *  element order.
    .                  */
    .                 const_iterator
    .                 end() const _GLIBCXX_NOEXCEPT
-- line 973 ----------------------------------------
-- line 1048 ----------------------------------------
    .           #endif
    .           
    .                 // [23.2.2.2] capacity
    .                 /**
    .                  *  Returns true if the %list is empty.  (Thus begin() would equal
    .                  *  end().)
    .                  */
    .                 _GLIBCXX_NODISCARD bool
  209 ( 0.01%)        empty() const _GLIBCXX_NOEXCEPT
   72 ( 0.00%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
   88 ( 0.00%)        { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }
    .           
    .                 /**  Returns the number of elements in the %list.  */
    .                 size_type
   57 ( 0.00%)        size() const _GLIBCXX_NOEXCEPT
  247 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
   39 ( 0.00%)        { return _M_node_count(); }
    .           
    .                 /**  Returns the size() of the largest possible %list.  */
    .                 size_type
    .                 max_size() const _GLIBCXX_NOEXCEPT
    .           
    .           #if __cplusplus >= 201103L
    .                 /**
-- line 1070 ----------------------------------------
-- line 1204 ----------------------------------------
    .                  *
    .                  *  This is a typical stack operation.  The function creates an
    .                  *  element at the end of the %list and assigns the given data to
    .                  *  it.  Due to the nature of a %list this operation can be done
    .                  *  in constant time, and does not invalidate iterators and
    .                  *  references.
    .                  */
    .                 void
  480 ( 0.02%)        push_back(const value_type& __x)
30,158 ( 1.24%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (12x)
  576 ( 0.02%)        { this->_M_insert(end(), __x); }
    .           
    .           #if __cplusplus >= 201103L
    .                 void
    .                 push_back(value_type&& __x)
    .           
    .                 template<typename... _Args>
    .           #if __cplusplus > 201402L
-- line 1221 ----------------------------------------
-- line 1902 ----------------------------------------
    .                 {
    .           	_Node* __tmp = _M_create_node(__x);
    .           	__tmp->_M_hook(__position._M_node);
    .           	this->_M_inc_size(1);
    .                 }
    .           #else
    .                template<typename... _Args>
    .                  void
  504 ( 0.02%)         _M_insert(iterator __position, _Args&&... __args)
53,492 ( 2.21%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
    .                  {
  408 ( 0.02%)  	 __tmp->_M_hook(__position._M_node);
  168 ( 0.01%)  	 this->_M_inc_size(1);
   72 ( 0.00%)         }
    .           #endif
    .           
    .                 // Erases element at position given.
    .                 void
    .                 _M_erase(iterator __position) _GLIBCXX_NOEXCEPT
    .                 {
    .           	this->_M_dec_size(1);
    .           	__position._M_node->_M_unhook();
-- line 1923 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/functional_hash.h
--------------------------------------------------------------------------------
Ir             

-- line 146 ----------------------------------------
    .           
    .             /// Explicit specialization for char32_t.
    .             _Cxx_hashtable_define_trivial_hash(char32_t)
    .           
    .             /// Explicit specialization for short.
    .             _Cxx_hashtable_define_trivial_hash(short)
    .           
    .             /// Explicit specialization for int.
1,311 ( 0.05%)    _Cxx_hashtable_define_trivial_hash(int)
3,707 ( 0.15%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (57x)
    .           
    .             /// Explicit specialization for long.
    .             _Cxx_hashtable_define_trivial_hash(long)
    .           
    .             /// Explicit specialization for long long.
    .             _Cxx_hashtable_define_trivial_hash(long long)
    .           
    .             /// Explicit specialization for unsigned short.
-- line 162 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/move.h
--------------------------------------------------------------------------------
Ir             

-- line 41 ----------------------------------------
    .           
    .             /**
    .              *  @ingroup utilities
    .              */
    .             template<typename _Tp>
    .               inline _GLIBCXX_CONSTEXPR _Tp*
  722 ( 0.03%)      __addressof(_Tp& __r) _GLIBCXX_NOEXCEPT
  652 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  114 ( 0.00%)      { return __builtin_addressof(__r); }
    .           
    .           #if __cplusplus >= 201103L
    .           
    .           _GLIBCXX_END_NAMESPACE_VERSION
    .           } // namespace
    .           
    .           
-- line 58 ----------------------------------------
-- line 69 ----------------------------------------
    .              *  @brief  Forward an lvalue.
    .              *  @return The parameter cast to the specified type.
    .              *
    .              *  This function is used to implement "perfect forwarding".
    .              */
    .             template<typename _Tp>
    .               _GLIBCXX_NODISCARD
    .               constexpr _Tp&&
3,057 ( 0.13%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (47x)
  819 ( 0.03%)      { return static_cast<_Tp&&>(__t); }
    .           
    .             /**
    .              *  @brief  Forward an rvalue.
    .              *  @return The parameter cast to the specified type.
    .              *
    .              *  This function is used to implement "perfect forwarding".
    .              */
    .             template<typename _Tp>
-- line 86 ----------------------------------------
-- line 137 ----------------------------------------
    .              *         referenced by r, even in the presence of an overloaded
    .              *         operator&.
    .              *  @param  __r  Reference to an object or function.
    .              *  @return   The actual address.
    .             */
    .             template<typename _Tp>
    .               _GLIBCXX_NODISCARD
    .               inline _GLIBCXX17_CONSTEXPR _Tp*
  209 ( 0.01%)      addressof(_Tp& __r) noexcept
1,534 ( 0.06%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
    .           
    .             // _GLIBCXX_RESOLVE_LIB_DEFECTS
    .             // 2598. addressof works on temporaries
    .             template<typename _Tp>
    .               const _Tp* addressof(const _Tp&&) = delete;
    .           
    .             template <typename _Tp, typename _Up = _Tp>
-- line 154 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/alloc_traits.h
--------------------------------------------------------------------------------
Ir           

-- line 455 ----------------------------------------
  .                 /**
  .                  *  @brief  Allocate memory.
  .                  *  @param  __n  The number of objects to allocate space for.
  .                  *
  .                  *  Calls @c a.allocate(n)
  .                 */
  .                 _GLIBCXX_NODISCARD static _GLIBCXX20_CONSTEXPR pointer
11,958 ( 0.49%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
540 ( 0.02%)        { return __a.allocate(__n); }
  .           
  .                 /**
  .                  *  @brief  Allocate memory.
  .                  *  @param  __n  The number of objects to allocate space for.
  .                  *  @param  __hint Aid to locality.
  .                  *  @return Memory of suitable size and alignment for @a n objects
  .                  *          of type @c value_type
-- line 472 ----------------------------------------
-- line 487 ----------------------------------------
  .                  *  @brief  Deallocate memory.
  .                  *  @param  __p  Pointer to the memory to deallocate.
  .                  *  @param  __n  The number of objects space was allocated for.
  .                  *
  .                  *  Calls <tt> a.deallocate(p, n) </tt>
  .                 */
  .                 static _GLIBCXX20_CONSTEXPR void
7,276 ( 0.30%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
504 ( 0.02%)        { __a.deallocate(__p, __n); }
  .           
  .                 /**
  .                  *  @brief  Construct an object of type `_Up`
  .                  *  @param  __p  Pointer to memory of suitable size and alignment for
  .                  *	       an object of type `_Up`.
  .                  *  @param  __args Constructor arguments.
  .                  *
  .                  *  in C++11, C++14 and C++17. Changed in C++20 to call
  .                 */
  .                 template<typename _Up, typename... _Args>
  .           	static _GLIBCXX20_CONSTEXPR void
10,138 ( 0.42%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
  .           		  _Args&&... __args)
  .           	{
  .           #if __cplusplus <= 201703L
  .           #else
  .           #endif
112 ( 0.00%)  	}
  .           
  .                 /**
  .                  *  @brief  Destroy an object of type @a _Up
  .                  *  @param  __p  Pointer to the object to destroy
  .                  *
  .                  *  Calls @c __a.destroy(__p).
  .                 */
  .                 template<typename _Up>
  .           	static _GLIBCXX20_CONSTEXPR void
1,534 ( 0.06%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .           	noexcept(is_nothrow_destructible<_Up>::value)
  .           	{
  .           #if __cplusplus <= 201703L
340 ( 0.01%)  	  __a.destroy(__p);
  .           #else
  .           #endif
102 ( 0.00%)  	}
  .           
  .                 /**
  .                  *  @brief  The maximum supported allocation size
  .                  *  @return @c __a.max_size()
  .                 */
  .                 static _GLIBCXX20_CONSTEXPR size_type
-- line 547 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: main.cpp
--------------------------------------------------------------------------------
Ir           

-- line 3 ----------------------------------------
  .           #include <vector>
  .           #include <unordered_map>
  .           #include <cstdlib>  // For srand() and rand()
  .           #include <ctime>    // For time()
  .           #include <getopt.h> // For getopt() to parse command line arguments
  .           #include "Graph.hpp"
  .           
  .           // Function to generate a random graph with the given number of vertices and edges
 21 ( 0.00%)  void generateRandomGraph(Graph *g, int vertices, int edges) {
186,552 ( 7.70%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18 (1x)
174 ( 0.01%)      for (int i = 0; i < edges; ++i) {
186,486 ( 7.70%)  => main.cpp:generateRandomGraph(Graph*, int, int)'2 (1x)
360 ( 0.01%)          int u = rand() % vertices;
162,452 ( 6.71%)  => main.cpp:generateRandomGraph(Graph*, int, int)'2 (1x)
156 ( 0.01%)  => ./stdlib/./stdlib/rand.c:rand (2x)
  .                   int v = rand() % vertices;
  .                   // Ensure no self-loop
132 ( 0.01%)          while (u == v) {
 66 ( 0.00%)              v = rand() % vertices;
220,950 ( 9.12%)  => /home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/Graph.hpp:Graph::addEdge(int, int)'2 (2x)
156 ( 0.01%)  => ./stdlib/./stdlib/rand.c:rand (2x)
  .                   }
124 ( 0.01%)          g->addEdge(u, v);
638,158 (26.34%)  => /home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/Graph.hpp:Graph::addEdge(int, int)'2 (9x)
186,274 ( 7.69%)  => /home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/Graph.hpp:Graph::addEdge(int, int) (1x)
  .               }
  4 ( 0.00%)  }
  .           
 42 ( 0.00%)  int main(int argc, char *argv[]) {
391,831 (16.17%)  => main.cpp:main'2 (1x)
 37 ( 0.00%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18 (1x)
 34 ( 0.00%)  => ./time/../sysdeps/unix/sysv/linux/time.c:time (1x)
  .               int vertices = 5;     // Default number of vertices
  .               int edges = 5;        // Default number of edges
  .               int seed = time(0);   // Default seed is current time
  .           
  .               // Parse command-line arguments using getopt
  .               int opt;
 92 ( 0.00%)      while ((opt = getopt(argc, argv, "v:e:s:")) != -1) {
1,172,166 (48.38%)  => ./posix/./posix/getopt.c:getopt'2 (3x)
391,822 (16.17%)  => ./posix/./posix/getopt.c:getopt (1x)
 31 ( 0.00%)          switch (opt) {
  .                   case 'v':
  9 ( 0.00%)              vertices = atoi(optarg);  
391,204 (16.15%)  => ./stdlib/./stdlib/atoi.c:atoi (1x)
  8 ( 0.00%)              break;
391,085 (16.14%)  => main.cpp:main'2 (1x)
  .                   case 'e':
  9 ( 0.00%)              edges = atoi(optarg);    
390,851 (16.13%)  => ./stdlib/./stdlib/atoi.c:atoi'2 (1x)
  8 ( 0.00%)              break;
390,732 (16.13%)  => main.cpp:main'2 (1x)
  .                   case 's':
  9 ( 0.00%)              seed = atoi(optarg);     
390,495 (16.12%)  => ./stdlib/./stdlib/atoi.c:atoi'2 (1x)
  1 ( 0.00%)              break;
390,376 (16.11%)  => main.cpp:main'2 (1x)
  .                   default:
  .                       return EXIT_FAILURE;
  .                   }
  .               }
  .           
  .               // Seed the random number generator
 19 ( 0.00%)      srand(seed);
384,776 (15.88%)  => ???:operator new(unsigned long) (1x)
5,453 ( 0.23%)  => ./stdlib/./stdlib/random.c:srand (1x)
  .           
  .               // Dynamically allocate memory for the graph object
 19 ( 0.00%)      Graph *g = new Graph(vertices);
384,540 (15.87%)  => /home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/Graph.hpp:Graph::Graph(int) (1x)
  .           
  .               // Generate a random graph
 11 ( 0.00%)      generateRandomGraph(g, vertices, edges);
383,366 (15.82%)  => main.cpp:generateRandomGraph(Graph*, int, int) (1x)
  .           
  .               // Find and print the Euler circuit (if it exists)
  9 ( 0.00%)      g->findEulerCircuit();
196,791 ( 8.12%)  => /home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/Graph.hpp:Graph::findEulerCircuit() (1x)
  .           
  .               // Deallocate the memory when we're done
 26 ( 0.00%)      delete g;
48,050 ( 1.98%)  => /home/aharonba123/Desktop/H.W/Semester_B/Operating_Systems/exe4/4/Graph.hpp:Graph::~Graph() (1x)
  .           
  8 ( 0.00%)      return 0;
 87 ( 0.00%)  }
116,788 ( 4.82%)  => ???:__gcov_exit (1x)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/ext/aligned_buffer.h
--------------------------------------------------------------------------------
Ir             

-- line 56 ----------------------------------------
    .                 alignas(__alignof__(_Tp2::_M_t)) unsigned char _M_storage[sizeof(_Tp)];
    .           
    .                 __aligned_membuf() = default;
    .           
    .                 // Can be used to avoid value-initialization zeroing _M_storage.
    .           
    .                 void*
1,368 ( 0.06%)        _M_addr() noexcept
4,682 ( 0.19%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (72x)
  216 ( 0.01%)        { return static_cast<void*>(&_M_storage); }
    .           
    .                 const void*
    .                 _M_addr() const noexcept
    .                 { return static_cast<const void*>(&_M_storage); }
    .           
    .                 _Tp*
1,368 ( 0.06%)        _M_ptr() noexcept
11,020 ( 0.45%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (72x)
1,008 ( 0.04%)        { return static_cast<_Tp*>(_M_addr()); }
    .           
    .                 const _Tp*
    .                 _M_ptr() const noexcept
    .                 { return static_cast<const _Tp*>(_M_addr()); }
    .               };
    .           
    .           #if _GLIBCXX_INLINE_VERSION
    .             template<typename _Tp>
-- line 81 ----------------------------------------
-- line 94 ----------------------------------------
    .           
    .                 __aligned_buffer() = default;
    .           
    .                 // Can be used to avoid value-initialization
    .           
    .                 void*
1,292 ( 0.05%)        _M_addr() noexcept
4,422 ( 0.18%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (68x)
    .                 {
   68 ( 0.00%)          return static_cast<void*>(&_M_storage);
  136 ( 0.01%)        }
    .           
    .                 const void*
  893 ( 0.04%)        _M_addr() const noexcept
3,057 ( 0.13%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (47x)
    .                 {
   47 ( 0.00%)          return static_cast<const void*>(&_M_storage);
   94 ( 0.00%)        }
    .           
    .                 _Tp*
1,292 ( 0.05%)        _M_ptr() noexcept
10,408 ( 0.43%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (68x)
  952 ( 0.04%)        { return static_cast<_Tp*>(_M_addr()); }
    .           
    .                 const _Tp*
  893 ( 0.04%)        _M_ptr() const noexcept
7,195 ( 0.30%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (47x)
  658 ( 0.03%)        { return static_cast<const _Tp*>(_M_addr()); }
    .               };
    .           #endif
    .           
    .           } // namespace
    .           
    .           #endif /* _ALIGNED_BUFFER_H */

--------------------------------------------------------------------------------
-- Auto-annotated source: Graph.hpp
--------------------------------------------------------------------------------
Ir             

    .           #include <iostream>
    .           #include <list>
    .           #include <vector>
    .           #include <unordered_map>
    .           #include <stack>
    .           
   32 ( 0.00%)  class Graph
    .           {
    .           private:
    .               int vertices;
    .           
    .               // Helper function to check if all non-zero degree vertices are connected
83,976 ( 3.47%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .               {
  230 ( 0.01%)          visited[v] = true;
1,454 ( 0.06%)          for (int u : adjList[v])
    .                   {
  696 ( 0.03%)              if (!visited[u])
    .                       {
  108 ( 0.00%)                  DFS(u, visited);
    .                       }
    .                   }
  100 ( 0.00%)      }
    .           
    .               // Function to check if the graph is connected (ignoring isolated vertices)
   25 ( 0.00%)      bool isConnected()
132,161 ( 5.46%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .               {
    .           
    .                   // Find a vertex with non-zero degree
    2 ( 0.00%)          int nonZeroDegreeVertex = -1;
   14 ( 0.00%)          for (int i = 0; i < vertices; ++i)
128,578 ( 5.31%)  => Graph.hpp:Graph::isConnected()'2 (1x)
    .                   {
   26 ( 0.00%)              if (!adjList[i].empty())
    .                       {
    9 ( 0.00%)                  nonZeroDegreeVertex = i;
    1 ( 0.00%)                  break;
125,826 ( 5.19%)  => Graph.hpp:Graph::isConnected()'2 (1x)
    .                       }
    .                   }
    .           
    .                   // If there are no edges in the graph, it is Eulerian
    3 ( 0.00%)          if (nonZeroDegreeVertex == -1)
    .                       return true;
    .           
    .                   // Perform DFS from the first non-zero degree vertex
   12 ( 0.00%)          DFS(nonZeroDegreeVertex, visited);
    .           
    .                   // Check if all vertices with non-zero degree are visited
  157 ( 0.01%)          for (int i = 0; i < vertices; ++i)
41,819 ( 1.73%)  => Graph.hpp:Graph::isConnected()'2 (1x)
    .                   {
  620 ( 0.03%)              if (!adjList[i].empty() && !visited[i])
    .                       {
    .                           return false;
    .                       }
    .                   }
    1 ( 0.00%)          return true;
   21 ( 0.00%)      }
    .           
    .               // Function to check if all vertices have even degree
   24 ( 0.00%)      bool hasEvenDegree()
8,838 ( 0.36%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .               {
   44 ( 0.00%)          for (int i = 0; i < vertices; ++i)
8,767 ( 0.36%)  => Graph.hpp:Graph::hasEvenDegree()'2 (1x)
    .                   {
   84 ( 0.00%)              if (adjList[i].size() % 2 != 0)
    .                       {
    9 ( 0.00%)                  return false;
   11 ( 0.00%)  => Graph.hpp:Graph::hasEvenDegree()'2 (1x)
    .                       }
    .                   }
    .                   return true;
   11 ( 0.00%)      }
    .           
    .           public:
   36 ( 0.00%)      Graph(int V) : vertices(V) {}
    .           
    .               // Add an edge between two vertices
  252 ( 0.01%)      void addEdge(int u, int v)
23,601 ( 0.97%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .               {
  276 ( 0.01%)          adjList[u].push_back(v);
  276 ( 0.01%)          adjList[v].push_back(u);
   36 ( 0.00%)      }
    .           
    .               // Function to check if an Euler circuit exists and to print the circuit if it does
   25 ( 0.00%)      void findEulerCircuit()
148,709 ( 6.14%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18 (1x)
    .               {
   14 ( 0.00%)          if (!isConnected())
148,638 ( 6.14%)  => Graph.hpp:Graph::isConnected() (1x)
    .                   {
    .                       return;
    .                   }
    .           
   22 ( 0.00%)          if (!hasEvenDegree())
7,587 ( 0.31%)  => Graph.hpp:Graph::findEulerCircuit()'2 (1x)
    .                   {
   18 ( 0.00%)  => Graph.hpp:Graph::findEulerCircuit()'2 (1x)
    1 ( 0.00%)              return;
   10 ( 0.00%)  => Graph.hpp:Graph::findEulerCircuit()'2 (1x)
    .                   }
    .           
    .           
    .                   // Start from any vertex with edges
    .                   int currentVertex = 0;
    .                   for (int i = 0; i < vertices; ++i)
-- line 103 ----------------------------------------
-- line 133 ----------------------------------------
    .           
    .                   // Print the Euler circuit
    .                   for (int vertex : circuit)
    .                   {
    .                   }
   10 ( 0.00%)      }
    .           };

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/utility
--------------------------------------------------------------------------------
Ir           

-- line 180 ----------------------------------------
  .           
  .                 template<typename _Tp1, typename _Tp2>
  .           	static constexpr _Tp1&&
  .           	__move_get(pair<_Tp1, _Tp2>&& __pair) noexcept
  .           
  .                 template<typename _Tp1, typename _Tp2>
  .           	static constexpr const _Tp1&
893 ( 0.04%)  	__const_get(const pair<_Tp1, _Tp2>& __pair) noexcept
3,057 ( 0.13%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (47x)
141 ( 0.01%)  	{ return __pair.first; }
  .           
  .                 template<typename _Tp1, typename _Tp2>
  .           	static constexpr const _Tp1&&
  .           	__const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept
  .               };
  .           
  .             template<>
-- line 197 ----------------------------------------
-- line 225 ----------------------------------------
  .           
  .             template<size_t _Int, class _Tp1, class _Tp2>
  .               constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
  .               get(pair<_Tp1, _Tp2>&& __in) noexcept
  .           
  .             template<size_t _Int, class _Tp1, class _Tp2>
  .               constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&
893 ( 0.04%)      get(const pair<_Tp1, _Tp2>& __in) noexcept
7,195 ( 0.30%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (47x)
658 ( 0.03%)      { return __pair_get<_Int>::__const_get(__in); }
  .           
  .             template<size_t _Int, class _Tp1, class _Tp2>
  .               constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&
  .               get(const pair<_Tp1, _Tp2>&& __in) noexcept
  .           
  .           #if __cplusplus >= 201402L
  .           
-- line 242 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/tuple
--------------------------------------------------------------------------------
Ir           

-- line 184 ----------------------------------------
  .           #endif
  .           
  .             template<size_t _Idx, typename _Head>
  .               struct _Head_base<_Idx, _Head, false>
  .               {
  .                 constexpr _Head_base()
  .                 : _M_head_impl() { }
  .           
200 ( 0.01%)        constexpr _Head_base(const _Head& __h)
682 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
 60 ( 0.00%)        : _M_head_impl(__h) { }
  .           
  .                 constexpr _Head_base(const _Head_base&) = default;
  .                 constexpr _Head_base(_Head_base&&) = default;
  .           
  .                 template<typename _UHead>
  .                   constexpr _Head_base(_UHead&& __h)
  .           
-- line 201 ----------------------------------------
-- line 225 ----------------------------------------
  .           	{ }
  .           
  .                 template<typename _Alloc, typename _UHead>
  .           	_GLIBCXX20_CONSTEXPR
  .           	_Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
  .           
  .                 static constexpr _Head&
230 ( 0.01%)        _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }
662 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .           
  .                 static constexpr const _Head&
  .                 _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }
  .           
  .                 _Head _M_head_impl;
  .               };
  .           
  .             /**
-- line 241 ----------------------------------------
-- line 416 ----------------------------------------
  .               struct _Tuple_impl<_Idx, _Head>
  .               : private _Head_base<_Idx, _Head>
  .               {
  .                 template<size_t, typename...> friend struct _Tuple_impl;
  .           
  .                 typedef _Head_base<_Idx, _Head> _Base;
  .           
  .                 static constexpr _Head&
330 ( 0.01%)        _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
  .           
  .                 static constexpr const _Head&
  .                 _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }
  .           
  .                 constexpr
  .                 _Tuple_impl()
  .                 : _Base() { }
  .           
  .                 explicit constexpr
200 ( 0.01%)        _Tuple_impl(const _Head& __head)
1,564 ( 0.06%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
100 ( 0.00%)        : _Base(__head)
 30 ( 0.00%)        { }
  .           
  .                 template<typename _UHead>
  .           	explicit constexpr
  .           	_Tuple_impl(_UHead&& __head)
  .           	{ }
  .           
  .                 constexpr _Tuple_impl(const _Tuple_impl&) = default;
-- line 444 ----------------------------------------
-- line 446 ----------------------------------------
  .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
  .                 _Tuple_impl& operator=(const _Tuple_impl&) = delete;
  .           
  .           #if _GLIBCXX_INLINE_VERSION
  .                 _Tuple_impl(_Tuple_impl&&) = default;
  .           #else
  .                 constexpr
200 ( 0.01%)        _Tuple_impl(_Tuple_impl&& __in)
692 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .                 noexcept(is_nothrow_move_constructible<_Head>::value)
 40 ( 0.00%)        : _Base(static_cast<_Base&&>(__in))
 30 ( 0.00%)        { }
  .           #endif
  .           
  .                 template<typename _UHead>
  .           	constexpr
  .           	_Tuple_impl(const _Tuple_impl<_Idx, _UHead>& __in)
  .           	: _Base(_Tuple_impl<_Idx, _UHead>::_M_head(__in))
  .           	{ }
  .           
-- line 465 ----------------------------------------
-- line 719 ----------------------------------------
  .           	explicit constexpr
  .           	tuple()
  .           	noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)
  .           	: _Inherited() { }
  .           
  .                 template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
  .           	       _ImplicitCtor<_NotEmpty, const _Elements&...> = true>
  .           	constexpr
200 ( 0.01%)  	tuple(const _Elements&... __elements)
2,446 ( 0.10%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .           	noexcept(__nothrow_constructible<const _Elements&...>())
130 ( 0.01%)  	: _Inherited(__elements...) { }
  .           
  .                 template<bool _NotEmpty = (sizeof...(_Elements) >= 1),
  .           	       _ExplicitCtor<_NotEmpty, const _Elements&...> = false>
  .           	explicit constexpr
  .           	tuple(const _Elements&... __elements)
  .           	noexcept(__nothrow_constructible<const _Elements&...>())
  .           	: _Inherited(__elements...) { }
  .           
-- line 737 ----------------------------------------
-- line 748 ----------------------------------------
  .           	       _ExplicitCtor<_Valid, _UElements...> = false>
  .           	explicit constexpr
  .           	tuple(_UElements&&... __elements)
  .           	noexcept(__nothrow_constructible<_UElements...>())
  .           
  .                 constexpr tuple(const tuple&) = default;
  .           
330 ( 0.01%)        constexpr tuple(tuple&&) = default;
  .           
  .                 template<typename... _UElements,
  .           	       bool _Valid = (sizeof...(_Elements) == sizeof...(_UElements))
  .           			   && !__use_other_ctor<const tuple<_UElements...>&>(),
  .           	       _ImplicitCtor<_Valid, const _UElements&...> = true>
  .           	constexpr
  .           	tuple(const tuple<_UElements...>& __in)
  .           	noexcept(__nothrow_constructible<const _UElements&...>())
-- line 764 ----------------------------------------
-- line 1369 ----------------------------------------
  .               struct tuple_element<__i, tuple<>>
  .               {
  .                 static_assert(__i < tuple_size<tuple<>>::value,
  .           	  "tuple index must be in range");
  .               };
  .           
  .             template<size_t __i, typename _Head, typename... _Tail>
  .               constexpr _Head&
190 ( 0.01%)      __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
2,426 ( 0.10%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
140 ( 0.01%)      { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
  .           
  .             template<size_t __i, typename _Head, typename... _Tail>
  .               constexpr const _Head&
  .               __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
  .               { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }
  .           
  .             // Deleted overload to improve diagnostics for invalid indices
  .             template<size_t __i, typename... _Types>
  .               __enable_if_t<(__i >= sizeof...(_Types))>
  .               __get_helper(const tuple<_Types...>&) = delete;
  .           
  .             /// Return a reference to the ith element of a tuple.
  .             template<size_t __i, typename... _Elements>
  .               constexpr __tuple_element_t<__i, tuple<_Elements...>>&
190 ( 0.01%)      get(tuple<_Elements...>& __t) noexcept
3,308 ( 0.14%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .           
  .             /// Return a const reference to the ith element of a const tuple.
  .             template<size_t __i, typename... _Elements>
  .               constexpr const __tuple_element_t<__i, tuple<_Elements...>>&
  .               get(const tuple<_Elements...>& __t) noexcept
  .           
  .             /// Return an rvalue reference to the ith element of a tuple rvalue.
-- line 1402 ----------------------------------------
-- line 1796 ----------------------------------------
  .              *
  .              * The elements of each tuple will be used as the constructor arguments
  .              * for the data members of the pair.
  .             */
  .             template<class _T1, class _T2>
  .               template<typename... _Args1, typename... _Args2>
  .                 _GLIBCXX20_CONSTEXPR
  .                 inline
230 ( 0.01%)        pair<_T1, _T2>::
12,218 ( 0.50%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .                 pair(piecewise_construct_t,
  .           	   tuple<_Args1...> __first, tuple<_Args2...> __second)
  .                 : pair(__first, __second,
  .           	     typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
140 ( 0.01%)  	     typename _Build_index_tuple<sizeof...(_Args2)>::__type())
 40 ( 0.00%)        { }
  .           
  .             template<class _T1, class _T2>
  .               template<typename... _Args1, size_t... _Indexes1,
  .           	     typename... _Args2, size_t... _Indexes2>
  .                 _GLIBCXX20_CONSTEXPR inline
230 ( 0.01%)        pair<_T1, _T2>::
11,256 ( 0.46%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .                 pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
  .           	   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
 30 ( 0.00%)        { }
  .           
  .           #if __cplusplus >= 201703L
  .           
  .             template<template<typename...> class _Trait, typename _Tp, typename _Tuple>
-- line 1829 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/new
--------------------------------------------------------------------------------
Ir             

-- line 167 ----------------------------------------
    .             _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
    .             _GLIBCXX_USE_NOEXCEPT __attribute__((__externally_visible__));
    .           #endif // __cpp_sized_deallocation
    .           #endif // __cpp_aligned_new
    .           
    .           // Default placement versions of operator new.
1,012 ( 0.04%)  { return __p; }
2,214 ( 0.09%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (34x)
    .           { return __p; }
    .           
    .           // Default placement versions of operator delete.
    .           inline void operator delete  (void*, void*) _GLIBCXX_USE_NOEXCEPT { }
    .           inline void operator delete[](void*, void*) _GLIBCXX_USE_NOEXCEPT { }
    .           //@}
    .           } // extern "C++"
-- line 183 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/unordered_map.h
--------------------------------------------------------------------------------
Ir           

-- line 94 ----------------------------------------
  .              *
  .              *  Base is _Hashtable, dispatched at compile time via template
  .              *  alias __umap_hashtable.
  .              */
  .             template<typename _Key, typename _Tp,
  .           	   typename _Hash = hash<_Key>,
  .           	   typename _Pred = equal_to<_Key>,
 31 ( 0.00%)      class unordered_map
  .               {
  .                 typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc>  _Hashtable;
  .                 _Hashtable _M_h;
  .           
  .               public:
  .                 // typedefs:
  .                 ///@{
  .                 /// Public typedefs.
-- line 110 ----------------------------------------
-- line 133 ----------------------------------------
  .           #if __cplusplus > 201402L
  .                 using node_type = typename _Hashtable::node_type;
  .                 using insert_return_type = typename _Hashtable::insert_return_type;
  .           #endif
  .           
  .                 //construct/destroy/copy
  .           
  .                 /// Default constructor.
 31 ( 0.00%)        unordered_map() = default;
  .           
  .                 /**
  .                  *  @brief  Default constructor creates no elements.
  .                  *  @param __n  Minimal initial number of buckets.
  .                  *  @param __hf  A hash functor.
  .                  *  @param __eql  A key equality functor.
  .                  */
-- line 149 ----------------------------------------
-- line 971 ----------------------------------------
  .                  *  Allows for easy lookup with the subscript ( @c [] )operator.  Returns
  .                  *  data associated with the key specified in subscript.  If the key does
  .                  *  not exist, a pair with that key is created using default values, which
  .                  *  is then returned.
  .                  *
  .                  *  Lookup requires constant time.
  .                  */
  .                 mapped_type&
960 ( 0.04%)        operator[](const key_type& __k)
60,980 ( 2.52%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (14x)
672 ( 0.03%)        { return _M_h[__k]; }
  .           
  .                 mapped_type&
  .                 operator[](key_type&& __k)
  .                 ///@}
  .           
  .                 ///@{
  .                 /**
-- line 988 ----------------------------------------

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Ir           

-- line 148 ----------------------------------------
  .                 using is_always_equal
  .           	= true_type;
  .           #endif
  .           
  .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
  .                 _GLIBCXX20_CONSTEXPR
  .           
  .                 _GLIBCXX20_CONSTEXPR
157 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
  .           
  .           #if __cplusplus >= 201103L
  .                 // Avoid implicit deprecation.
  .           #endif
  .           
  .                 template<typename _Tp1>
  .           	_GLIBCXX20_CONSTEXPR
  .           
  .           #if __cpp_constexpr_dynamic_alloc
  .                 constexpr
  .           #endif
  .           
  .           #if __cplusplus > 201703L
  .                 [[nodiscard,__gnu__::__always_inline__]]
  .                 constexpr _Tp*
  .                 allocate(size_t __n)
  .                 {
  .           #ifdef __cpp_lib_is_constant_evaluated
-- line 182 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/ptr_traits.h
--------------------------------------------------------------------------------
Ir           

-- line 141 ----------------------------------------
  .                   using rebind = _Up*;
  .           
  .                 /**
  .                  *  @brief  Obtain a pointer to an object
  .                  *  @param  __r  A reference to an object of type @c element_type
  .                  *  @return @c addressof(__r)
  .                 */
  .                 static _GLIBCXX20_CONSTEXPR pointer
209 ( 0.01%)        pointer_to(__make_not_void<element_type>& __r) noexcept
2,416 ( 0.10%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .               };
  .           
  .             /// Convenience alias for rebinding pointers.
  .             template<typename _Ptr, typename _Tp>
  .               using __ptr_rebind = typename pointer_traits<_Ptr>::template rebind<_Tp>;
  .           
  .             template<typename _Tp>
  .               constexpr _Tp*
209 ( 0.01%)      __to_address(_Tp* __ptr) noexcept
652 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  .               {
 11 ( 0.00%)        return __ptr;
 22 ( 0.00%)      }
  .           
  .           #if __cplusplus <= 201703L
  .             template<typename _Ptr>
  .               __to_address(const _Ptr& __ptr)
  .           #else
  .           
-- line 171 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/hashtable_policy.h
--------------------------------------------------------------------------------
Ir             

-- line 85 ----------------------------------------
    .                 operator()(_Tp&& __x) const noexcept
    .             };
    .           
    .             struct _Select1st
    .             {
    .               template<typename _Tp>
    .                 auto
  940 ( 0.04%)        operator()(_Tp&& __x) const noexcept
15,426 ( 0.64%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (47x)
    .             };
    .           
    .             template<typename _NodeAlloc>
    .               struct _Hashtable_alloc;
    .           
    .             // Functor recycling a pool of nodes and using allocation once the pool is
    .             // empty.
    .             template<typename _NodeAlloc>
-- line 103 ----------------------------------------
-- line 211 ----------------------------------------
    .              *  template parameter of class template _Hashtable controls whether
    .              *  nodes also store a hash code. In some cases (e.g. strings) this
    .              *  may be a performance win.
    .              */
    .             struct _Hash_node_base
    .             {
    .               _Hash_node_base* _M_nxt;
    .           
  264 ( 0.01%)      _Hash_node_base() noexcept : _M_nxt() { }
  741 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (11x)
    .           
    .               _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
    .             };
    .           
    .             /**
    .              *  struct _Hash_node_value_base
    .              *
    .              *  Node type with the value to store.
-- line 227 ----------------------------------------
-- line 229 ----------------------------------------
    .             template<typename _Value>
    .               struct _Hash_node_value_base
    .               {
    .                 typedef _Value value_type;
    .           
    .           
    .                 _Value*
1,292 ( 0.05%)        _M_valptr() noexcept
16,400 ( 0.68%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (68x)
  952 ( 0.04%)        { return _M_storage._M_ptr(); }
    .           
    .                 const _Value*
  893 ( 0.04%)        _M_valptr() const noexcept
11,333 ( 0.47%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (47x)
  658 ( 0.03%)        { return _M_storage._M_ptr(); }
    .           
    .                 _Value&
  722 ( 0.03%)        _M_v() noexcept
12,506 ( 0.52%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (38x)
  532 ( 0.02%)        { return *_M_valptr(); }
    .           
    .                 const _Value&
  893 ( 0.04%)        _M_v() const noexcept
15,473 ( 0.64%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (47x)
  658 ( 0.03%)        { return *_M_valptr(); }
    .               };
    .           
    .             /**
    .              *  Primary template struct _Hash_node_code_cache.
    .              */
    .             template<bool _Cache_hash_code>
    .               struct _Hash_node_code_cache
    .               { };
-- line 258 ----------------------------------------
-- line 269 ----------------------------------------
    .               : _Hash_node_value_base<_Value>
    .               , _Hash_node_code_cache<_Cache_hash_code>
    .               { };
    .           
    .             /**
    .              *  Primary template struct _Hash_node.
    .              */
    .             template<typename _Value, bool _Cache_hash_code>
  310 ( 0.01%)      struct _Hash_node
    .               : _Hash_node_base
    .               , _Hash_node_value<_Value, _Cache_hash_code>
    .               {
    .                 _Hash_node*
  361 ( 0.01%)        _M_next() const noexcept
  664 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
   76 ( 0.00%)        { return static_cast<_Hash_node*>(this->_M_nxt); }
    .               };
    .           
    .             /// Base class for node iterators.
    .             template<typename _Value, bool _Cache_hash_code>
    .               struct _Node_iterator_base
    .               {
    .                 using __node_type = _Hash_node<_Value, _Cache_hash_code>;
    .           
    .                 __node_type* _M_cur;
    .           
    .                 _Node_iterator_base() : _M_cur(nullptr) { }
  200 ( 0.01%)        _Node_iterator_base(__node_type* __p) noexcept
  682 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
   60 ( 0.00%)        : _M_cur(__p) { }
    .           
    .                 void
    .                 _M_incr() noexcept
    .                 { _M_cur = _M_cur->_M_next(); }
    .           
    .                 friend bool
    .                 operator==(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
    .                 noexcept
-- line 304 ----------------------------------------
-- line 330 ----------------------------------------
    .           				  const value_type*, value_type*>::type;
    .           
    .           				  const value_type&, value_type&>::type;
    .           
    .                 _Node_iterator() = default;
    .           
    .                 explicit
  200 ( 0.01%)        _Node_iterator(__node_type* __p) noexcept
1,564 ( 0.06%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  130 ( 0.01%)        : __base_type(__p) { }
    .           
    .                 reference
    .                 operator*() const noexcept
    .                 { return this->_M_cur->_M_v(); }
    .           
    .                 pointer
  190 ( 0.01%)        operator->() const noexcept
3,314 ( 0.14%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
  160 ( 0.01%)        { return this->_M_cur->_M_valptr(); }
    .           
    .                 _Node_iterator&
    .                 operator++() noexcept
    .                 {
    .           	this->_M_incr();
    .           	return *this;
    .                 }
    .           
-- line 355 ----------------------------------------
-- line 420 ----------------------------------------
    .             /// into the range [0, N).
    .             struct _Mod_range_hashing
    .             {
    .           
    .               result_type
1,218 ( 0.05%)      operator()(first_argument_type __num,
4,064 ( 0.17%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (58x)
    .           	       second_argument_type __den) const noexcept
  464 ( 0.02%)      { return __num % __den; }
    .             };
    .           
    .             /// Default ranged hash function H.  In principle it should be a
    .             /// function object composed from objects of type H1 and H2 such that
    .             /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
    .             /// h1 and h2.  So instead we'll just use a tag to tell class template
    .             /// hashtable to do that composition.
    .             struct _Default_ranged_hash { };
    .           
    .             /// Default value for rehash policy.  Bucket size is (usually) the
    .             /// smallest prime that keeps the load factor small enough.
    .             struct _Prime_rehash_policy
    .             {
    .               using __has_load_factor = true_type;
    .           
   20 ( 0.00%)      _Prime_rehash_policy(float __z = 1.0) noexcept
   72 ( 0.00%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    8 ( 0.00%)      : _M_max_load_factor(__z), _M_next_resize(0) { }
    .           
    .               float
    .               max_load_factor() const noexcept
    .               { return _M_max_load_factor; }
    .           
    .               // Return a bucket size no smaller than n.
-- line 455 ----------------------------------------
-- line 465 ----------------------------------------
    .               // is the new bucket count.  If not, return make_pair(false, 0).
    .           
    .           
    .               _State
  190 ( 0.01%)      _M_state() const
  662 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
   40 ( 0.00%)      { return _M_next_resize; }
    .           
    .               void
    .               _M_reset() noexcept
    .               { _M_next_resize = 0; }
    .           
    .               void
    .               _M_reset(_State __state)
    .               { _M_next_resize = __state; }
-- line 482 ----------------------------------------
-- line 688 ----------------------------------------
    .                 const mapped_type&
    .                 at(const key_type& __k) const;
    .               };
    .           
    .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               auto
1,248 ( 0.05%)      _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
179,402 ( 7.40%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (48x)
    .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    .               operator[](const key_type& __k)
    .               -> mapped_type&
    .               {
   96 ( 0.00%)        __hashtable* __h = static_cast<__hashtable*>(this);
  576 ( 0.02%)        __hash_code __code = __h->_M_hash_code(__k);
1,168 ( 0.05%)        if (auto __node = __h->_M_find_node(__bkt, __k, __code))
  494 ( 0.02%)  	return __node->_M_v().second;
    .           
  180 ( 0.01%)        typename __hashtable::_Scoped_node __node {
    .           	__h,
    .                 };
    .                 auto __pos
  150 ( 0.01%)  	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
   10 ( 0.00%)        __node._M_node = nullptr;
  110 ( 0.00%)        return __pos->second;
  932 ( 0.04%)      }
    .           
    .             template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    .           	   typename _Hash, typename _RangeHash, typename _Unused,
    .           	   typename _RehashPolicy, typename _Traits>
    .               auto
    .               _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
    .           	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
    .               operator[](key_type&& __k)
-- line 725 ----------------------------------------
-- line 1116 ----------------------------------------
    .              *  final) and when it is worth it (the type is empty.)
    .              */
    .             template<int _Nm, typename _Tp,
    .           	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    .               struct _Hashtable_ebo_helper;
    .           
    .             /// Specialization using EBO.
    .             template<int _Nm, typename _Tp>
   31 ( 0.00%)      struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    .               : private _Tp
    .               {
   75 ( 0.00%)        _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
    .           
    .                 template<typename _OtherTp>
    .           	_Hashtable_ebo_helper(_OtherTp&& __tp)
    .           	{ }
    .           
2,090 ( 0.09%)        const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
2,472 ( 0.10%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (38x)
  924 ( 0.04%)        _Tp& _M_get() { return static_cast<_Tp&>(*this); }
2,732 ( 0.11%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (42x)
    .               };
    .           
    .             /// Specialization not using EBO.
    .             template<int _Nm, typename _Tp>
    .               struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    .               {
    .                 _Hashtable_ebo_helper() = default;
    .           
-- line 1143 ----------------------------------------
-- line 1202 ----------------------------------------
    .                 hash_function() const
    .                 { return _M_hash(); }
    .           
    .               protected:
    .           
    .                 // We need the default constructor for the local iterators and _Hashtable
    .                 // default constructor.
   31 ( 0.00%)        _Hash_code_base() = default;
    .           
    .                 _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }
    .           
    .                 __hash_code
1,140 ( 0.05%)        _M_hash_code(const _Key& __k) const
15,944 ( 0.66%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (48x)
    .                 {
    .           	static_assert(__is_invocable<const _Hash&, const _Key&>{},
    .           	    "hash function must be invocable with an argument of key type");
1,425 ( 0.06%)  	return _M_hash()(__k);
  114 ( 0.00%)        }
    .           
    .                 template<typename _Kt>
    .           	__hash_code
    .           	_M_hash_code_tr(const _Kt& __k) const
    .           	{
    .           	  static_assert(__is_invocable<const _Hash&, const _Kt&>{},
    .           	    "hash function must be invocable with an argument of key type");
    .           	  return _M_hash()(__k);
    .           	}
    .           
8,579 ( 0.35%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (49x)
1,176 ( 0.05%)        { return _RangeHash{}(__c, __bkt_count); }
    .           
  234 ( 0.01%)        _M_bucket_index(const _Hash_node_value<_Value, false>& __n,
11,128 ( 0.46%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (9x)
    .           	noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>()))
    .           		  && noexcept(declval<const _RangeHash&>()((__hash_code)0,
    .                 {
  333 ( 0.01%)  	return _RangeHash{}(_M_hash_code(_ExtractKey{}(__n._M_v())),
   81 ( 0.00%)  			    __bkt_count);
   90 ( 0.00%)        }
    .           
    .                 _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
    .           	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
    .                 { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
    .           
    .                 void
  210 ( 0.01%)        _M_store_code(_Hash_node_code_cache<false>&, __hash_code) const
  652 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
   30 ( 0.00%)        { }
    .           
    .                 void
    .                 _M_copy_code(_Hash_node_code_cache<false>&,
    .           		   const _Hash_node_code_cache<false>&) const
    .                 { }
    .           
    .                 void
    .                 _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
-- line 1263 ----------------------------------------
-- line 1268 ----------------------------------------
    .           		   const _Hash_node_code_cache<true>& __from) const
    .                 { __to._M_hash_code = __from._M_hash_code; }
    .           
    .                 void
    .                 _M_swap(_Hash_code_base& __x)
    .           
    .                 const _Hash&
1,881 ( 0.08%)        _M_hash() const { return __ebo_hash::_M_cget(); }
    .               };
    .           
    .             /// Partial specialization used when nodes contain a cached hash code.
    .             template<typename _Key, typename _Value, typename _ExtractKey,
    .           	   typename _Hash, typename _RangeHash, typename _Unused>
    .               struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    .           				_Hash, _RangeHash, _Unused, true>
    .               : public _Node_iterator_base<_Value, true>
-- line 1284 ----------------------------------------
-- line 1578 ----------------------------------------
    .           					       __hash_cached::value>;
    .           
    .                 using __hash_code = typename __hash_code_base::__hash_code;
    .           
    .               private:
    .                 using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
    .           
    .                 static bool
  760 ( 0.03%)        _S_equals(__hash_code, const _Hash_node_code_cache<false>&)
2,472 ( 0.10%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (38x)
  114 ( 0.00%)        { return true; }
    .           
    .                 static bool
    .                 _S_node_equals(const _Hash_node_code_cache<false>&,
    .           		     const _Hash_node_code_cache<false>&)
    .                 { return true; }
    .           
    .                 static bool
    .                 _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
-- line 1595 ----------------------------------------
-- line 1596 ----------------------------------------
    .                 { return __c == __n._M_hash_code; }
    .           
    .                 static bool
    .                 _S_node_equals(const _Hash_node_code_cache<true>& __lhn,
    .           		     const _Hash_node_code_cache<true>& __rhn)
    .                 { return __lhn._M_hash_code == __rhn._M_hash_code; }
    .           
    .               protected:
   40 ( 0.00%)        _Hashtable_base() = default;
    .           
    .                 _Hashtable_base(const _Hash& __hash, const _Equal& __eq)
    .                 : __hash_code_base(__hash), _EqualEBO(__eq)
    .                 { }
    .           
    .                 bool
1,064 ( 0.04%)        _M_equals(const _Key& __k, __hash_code __c,
43,904 ( 1.81%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (38x)
    .           		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
    .                 {
    .           	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
    .           	  "key equality predicate must be invocable with two arguments of "
    .           	  "key type");
2,546 ( 0.11%)  	return _S_equals(__c, __n) && _M_eq()(__k, _ExtractKey{}(__n._M_v()));
  418 ( 0.02%)        }
    .           
    .                 template<typename _Kt>
    .           	bool
    .           	_M_equals_tr(const _Kt& __k, __hash_code __c,
    .           		     const _Hash_node_value<_Value,
    .           					    __hash_cached::value>& __n) const
    .           	{
    .           	  static_assert(
-- line 1626 ----------------------------------------
-- line 1642 ----------------------------------------
    .                 void
    .                 _M_swap(_Hashtable_base& __x)
    .                 {
    .           	__hash_code_base::_M_swap(__x);
    .                 }
    .           
    .                 const _Equal&
1,254 ( 0.05%)        _M_eq() const { return _EqualEBO::_M_cget(); }
    .               };
    .           
    .             /**
    .              *  Primary class template  _Equality.
    .              *
    .              *  This is for implementing equality comparison for unordered
    .              *  containers, per N3068, by John Lakos and Pablo Halpern.
    .              *  Algorithmically, we follow closely the reference implementations
-- line 1658 ----------------------------------------
-- line 1794 ----------------------------------------
    .                 return true;
    .               }
    .           
    .             /**
    .              * through inheritance to benefit from EBO when possible.
    .              */
    .             template<typename _NodeAlloc>
   31 ( 0.00%)      struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
    .               {
    .               private:
    .                 using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
    .               public:
    .                 using __node_type = typename _NodeAlloc::value_type;
    .                 using __node_alloc_type = _NodeAlloc;
-- line 1810 ----------------------------------------
-- line 1815 ----------------------------------------
    .                 using __node_ptr = __node_type*;
    .                 using __node_base = _Hash_node_base;
    .                 using __node_base_ptr = __node_base*;
    .                 using __buckets_alloc_type =
    .           	__alloc_rebind<__node_alloc_type, __node_base_ptr>;
    .                 using __buckets_ptr = __node_base_ptr*;
    .           
   31 ( 0.00%)        _Hashtable_alloc() = default;
    .                 _Hashtable_alloc(const _Hashtable_alloc&) = default;
    .                 _Hashtable_alloc(_Hashtable_alloc&&) = default;
    .           
    .                 template<typename _Alloc>
    .           	_Hashtable_alloc(_Alloc&& __a)
    .           	{ }
    .           
    .                 __node_alloc_type&
3,376 ( 0.14%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (22x)
  588 ( 0.02%)        { return __ebo_node_alloc::_M_get(); }
    .           
    .                 const __node_alloc_type&
    .                 { return __ebo_node_alloc::_M_cget(); }
    .           
    .                 // Allocate a node and construct an element within it.
    .                 template<typename... _Args>
    .           	__node_ptr
-- line 1842 ----------------------------------------
-- line 1862 ----------------------------------------
    .               };
    .           
    .             // Definitions of class template _Hashtable_alloc's out-of-line member
    .             // functions.
    .             template<typename _NodeAlloc>
    .               template<typename... _Args>
    .                 auto
  240 ( 0.01%)        _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
40,704 ( 1.68%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
    .                 -> __node_ptr
    .                 {
    .           	__try
    .           	  {
  210 ( 0.01%)  	    ::new ((void*)__n) __node_type;
    .           					   __n->_M_valptr(),
  100 ( 0.00%)  	    return __n;
    .           	  }
    .           	__catch(...)
    .           	  {
    .           	    __throw_exception_again;
    .           	  }
   40 ( 0.00%)        }
    .           
    .             template<typename _NodeAlloc>
    .               void
  210 ( 0.01%)      _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
4,989 ( 0.21%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .               {
  100 ( 0.00%)        _M_deallocate_node_ptr(__n);
   40 ( 0.00%)      }
    .           
    .             template<typename _NodeAlloc>
    .               void
  200 ( 0.01%)      _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
8,216 ( 0.34%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
    .               {
    .                 typedef typename __node_alloc_traits::pointer _Ptr;
    .                 __n->~__node_type();
   30 ( 0.00%)      }
    .           
    .             template<typename _NodeAlloc>
    .               void
   20 ( 0.00%)      _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
45,572 ( 1.88%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .               {
  111 ( 0.00%)        while (__n)
    .           	{
   20 ( 0.00%)  	  __node_ptr __tmp = __n;
  100 ( 0.00%)  	  __n = __n->_M_next();
   30 ( 0.00%)  	  _M_deallocate_node(__tmp);
    .           	}
    3 ( 0.00%)      }
    .           
    .             template<typename _NodeAlloc>
    .               auto
1,260 ( 0.05%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .               -> __buckets_ptr
    .               {
    .           
   12 ( 0.00%)        auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
   15 ( 0.00%)        __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
   21 ( 0.00%)  => ./string/../sysdeps/aarch64/memset.S:__GI_memset (1x)
    1 ( 0.00%)        return __p;
   18 ( 0.00%)      }
    .           
    .             template<typename _NodeAlloc>
    .               void
   27 ( 0.00%)      _Hashtable_alloc<_NodeAlloc>::
1,186 ( 0.05%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .               _M_deallocate_buckets(__buckets_ptr __bkts,
    .               {
    .                 typedef typename __buckets_alloc_traits::pointer _Ptr;
   11 ( 0.00%)        __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
   19 ( 0.00%)      }
    .           
    .            ///@} hashtable-detail
    .           } // namespace __detail
    .           /// @endcond
    .           _GLIBCXX_END_NAMESPACE_VERSION
    .           } // namespace std
    .           
    .           #endif // _HASHTABLE_POLICY_H
-- line 1951 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_function.h
--------------------------------------------------------------------------------
Ir           

-- line 361 ----------------------------------------
  .           #endif
  .           
  .             /// One of the @link comparison_functors comparison functors@endlink.
  .             template<typename _Tp>
  .               struct equal_to : public binary_function<_Tp, _Tp, bool>
  .               {
  .                 _GLIBCXX14_CONSTEXPR
  .                 bool
798 ( 0.03%)        operator()(const _Tp& __x, const _Tp& __y) const
2,700 ( 0.11%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (38x)
342 ( 0.01%)        { return __x == __y; }
  .               };
  .           
  .             /// One of the @link comparison_functors comparison functors@endlink.
  .             template<typename _Tp>
  .               struct not_equal_to : public binary_function<_Tp, _Tp, bool>
  .               {
  .                 _GLIBCXX14_CONSTEXPR
  .                 bool
-- line 378 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/allocated_ptr.h
--------------------------------------------------------------------------------
Ir           

-- line 45 ----------------------------------------
  .             template<typename _Alloc>
  .               struct __allocated_ptr
  .               {
  .           
  .                 /// Take ownership of __ptr
504 ( 0.02%)        __allocated_ptr(_Alloc& __a, pointer __ptr) noexcept
3,772 ( 0.16%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
 72 ( 0.00%)        { }
  .           
  .                 template<typename _Ptr,
  .           	       typename _Req = _Require<is_same<_Ptr, value_type*>>>
  .                 __allocated_ptr(_Alloc& __a, _Ptr __ptr)
  .           	_M_ptr(pointer_traits<pointer>::pointer_to(*__ptr))
  .                 { }
  .           
  .                 /// Transfer ownership of the owned pointer
  .                 __allocated_ptr(__allocated_ptr&& __gd) noexcept
  .                 : _M_alloc(__gd._M_alloc), _M_ptr(__gd._M_ptr)
  .                 { __gd._M_ptr = nullptr; }
  .           
  .                 /// Deallocate the owned pointer
456 ( 0.02%)        ~__allocated_ptr()
1,658 ( 0.07%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
  .                 {
 96 ( 0.00%)  	if (_M_ptr != nullptr)
 72 ( 0.00%)        }
  .           
  .                 /// Release ownership of the owned pointer
  .                 __allocated_ptr&
1,610 ( 0.07%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
  .                 {
 48 ( 0.00%)  	_M_ptr = nullptr;
 24 ( 0.00%)  	return *this;
 48 ( 0.00%)        }
  .           
  .                 /// Get the address that the owned pointer refers to.
  .           
  .               private:
  .                 _Alloc* _M_alloc;
  .                 pointer _M_ptr;
  .               };
-- line 91 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_bvector.h
--------------------------------------------------------------------------------
Ir             

-- line 69 ----------------------------------------
    .             typedef unsigned long _Bit_type;
    .             enum { _S_word_bit = int(__CHAR_BIT__ * sizeof(_Bit_type)) };
    .           
    .             struct _Bit_reference
    .             {
    .               _Bit_type * _M_p;
    .               _Bit_type _M_mask;
    .           
  924 ( 0.04%)      _Bit_reference(_Bit_type * __x, _Bit_type __y)
3,126 ( 0.13%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (44x)
  396 ( 0.02%)      : _M_p(__x), _M_mask(__y) { }
    .           
    .               _Bit_reference() _GLIBCXX_NOEXCEPT : _M_p(0), _M_mask(0) { }
    .           
    .           #if __cplusplus >= 201103L
    .               _Bit_reference(const _Bit_reference&) = default;
    .           #endif
    .           
  646 ( 0.03%)      operator bool() const _GLIBCXX_NOEXCEPT
  150 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
  374 ( 0.02%)      { return !!(*_M_p & _M_mask); }
    .           
    .               _Bit_reference&
  200 ( 0.01%)      operator=(bool __x) _GLIBCXX_NOEXCEPT
   87 ( 0.00%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .               {
  100 ( 0.00%)        if (__x)
  100 ( 0.00%)  	*_M_p |= _M_mask;
    .                 else
    .           	*_M_p &= ~_M_mask;
   10 ( 0.00%)        return *this;
   20 ( 0.00%)      }
    .           
    .               _Bit_reference&
    .               operator=(const _Bit_reference& __x) _GLIBCXX_NOEXCEPT
    .               { return *this = bool(__x); }
    .           
    .               bool
    .               operator==(const _Bit_reference& __x) const
    .               { return bool(*this) == bool(__x); }
-- line 105 ----------------------------------------
-- line 140 ----------------------------------------
    .           #endif
    .           
    .             struct _Bit_iterator_base
    .             {
    .               _Bit_type * _M_p;
    .               unsigned int _M_offset;
    .           
1,029 ( 0.04%)      _Bit_iterator_base(_Bit_type * __x, unsigned int __y)
3,483 ( 0.14%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (49x)
  441 ( 0.02%)      : _M_p(__x), _M_offset(__y) { }
    .           
    .               void
    .               _M_bump_up()
    .               {
    .                 if (_M_offset++ == int(_S_word_bit) - 1)
    .           	{
    .           	  _M_offset = 0;
    .           	  ++_M_p;
-- line 157 ----------------------------------------
-- line 164 ----------------------------------------
    .                 if (_M_offset-- == 0)
    .           	{
    .           	  _M_offset = int(_S_word_bit) - 1;
    .           	  --_M_p;
    .           	}
    .               }
    .           
    .               void
  900 ( 0.04%)      _M_incr(ptrdiff_t __i)
4,277 ( 0.18%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (45x)
    .               {
  270 ( 0.01%)        difference_type __n = __i + _M_offset;
  495 ( 0.02%)        _M_p += __n / int(_S_word_bit);
  270 ( 0.01%)        __n = __n % int(_S_word_bit);
  135 ( 0.01%)        if (__n < 0)
    .           	{
    .           	  __n += int(_S_word_bit);
    .           	  --_M_p;
    .           	}
  180 ( 0.01%)        _M_offset = static_cast<unsigned int>(__n);
  135 ( 0.01%)      }
    .           
    .               friend _GLIBCXX20_CONSTEXPR bool
    .               operator==(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
    .               { return __x._M_p == __y._M_p && __x._M_offset == __y._M_offset; }
    .           
    .           #if __cpp_lib_three_way_comparison
    .               friend constexpr strong_ordering
    .               operator<=>(const _Bit_iterator_base& __x, const _Bit_iterator_base& __y)
-- line 191 ----------------------------------------
-- line 233 ----------------------------------------
    .               typedef _Bit_reference  reference;
    .           #if __cplusplus > 201703L
    .               typedef void	    pointer;
    .           #else
    .               typedef _Bit_reference* pointer;
    .           #endif
    .               typedef _Bit_iterator   iterator;
    .           
  132 ( 0.01%)      _Bit_iterator() : _Bit_iterator_base(0, 0) { }
    .           
  945 ( 0.04%)      _Bit_iterator(_Bit_type * __x, unsigned int __y)
7,251 ( 0.30%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (45x)
  630 ( 0.03%)      : _Bit_iterator_base(__x, __y) { }
    .           
    .               iterator
    .               _M_const_cast() const
    .               { return *this; }
    .           
    .               reference
1,056 ( 0.04%)      operator*() const
8,056 ( 0.33%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (44x)
1,364 ( 0.06%)      { return reference(_M_p, 1UL << _M_offset); }
    .           
    .               iterator&
    .               operator++()
    .               {
    .                 _M_bump_up();
    .                 return *this;
    .               }
    .           
-- line 260 ----------------------------------------
-- line 277 ----------------------------------------
    .               operator--(int)
    .               {
    .                 iterator __tmp = *this;
    .                 _M_bump_down();
    .                 return __tmp;
    .               }
    .           
    .               iterator&
  900 ( 0.04%)      operator+=(difference_type __i)
8,239 ( 0.34%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (45x)
    .               {
  450 ( 0.02%)        _M_incr(__i);
   45 ( 0.00%)        return *this;
   90 ( 0.00%)      }
    .           
    .               iterator&
    .               operator-=(difference_type __i)
    .               {
    .                 *this += -__i;
    .                 return *this;
    .               }
    .           
    .               reference
1,100 ( 0.05%)      operator[](difference_type __i) const
26,628 ( 1.10%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (44x)
1,452 ( 0.06%)      { return *(*this + __i); }
    .           
    .               friend iterator
1,170 ( 0.05%)      operator+(const iterator& __x, difference_type __n)
13,328 ( 0.55%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (45x)
    .               {
  135 ( 0.01%)        iterator __tmp = __x;
  450 ( 0.02%)        __tmp += __n;
  360 ( 0.01%)        return __tmp;
  540 ( 0.02%)      }
    .           
    .               friend iterator
    .               operator+(difference_type __n, const iterator& __x)
    .               { return __x + __n; }
    .           
    .               friend iterator
    .               operator-(const iterator& __x, difference_type __n)
    .               {
-- line 316 ----------------------------------------
-- line 435 ----------------------------------------
    .           	  _Bit_type* _M_p;
    .           	  // Allow assignment from iterators (assume offset is zero):
    .           	  void operator=(_Bit_iterator __it) { _M_p = __it._M_p; }
    .           	} _M_start;
    .           #endif
    .           	_Bit_iterator	_M_finish;
    .           	_Bit_pointer	_M_end_of_storage;
    .           
   38 ( 0.00%)  	_Bvector_impl_data() _GLIBCXX_NOEXCEPT
  874 ( 0.04%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
   42 ( 0.00%)  	: _M_start(), _M_finish(), _M_end_of_storage()
    6 ( 0.00%)  	{ }
    .           
    .           #if __cplusplus >= 201103L
    .           	_Bvector_impl_data(const _Bvector_impl_data&) = default;
    .           	_Bvector_impl_data&
    .           	operator=(const _Bvector_impl_data&) = default;
    .           
    .           	_Bvector_impl_data(_Bvector_impl_data&& __x) noexcept
    .           	: _Bvector_impl_data(__x)
-- line 453 ----------------------------------------
-- line 457 ----------------------------------------
    .           	_M_move_data(_Bvector_impl_data&& __x) noexcept
    .           	{
    .           	  *this = __x;
    .           	  __x._M_reset();
    .           	}
    .           #endif
    .           
    .           	void
   24 ( 0.00%)  	_M_reset() _GLIBCXX_NOEXCEPT
  541 ( 0.02%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
   26 ( 0.00%)  	{ *this = _Bvector_impl_data(); }
    .           
    .           	void
    .           	_M_swap_data(_Bvector_impl_data& __x) _GLIBCXX_NOEXCEPT
    .           	{
    .           	  // information used by TBAA.
    .           	}
    .                 };
    .           
   31 ( 0.00%)        struct _Bvector_impl
    .           	: public _Bit_alloc_type, public _Bvector_impl_data
    .                 {
    .           	_Bvector_impl() _GLIBCXX_NOEXCEPT_IF(
    .           	  is_nothrow_default_constructible<_Bit_alloc_type>::value)
    .           	: _Bit_alloc_type()
    .           	{ }
    .           
   20 ( 0.00%)  	_Bvector_impl(const _Bit_alloc_type& __a) _GLIBCXX_NOEXCEPT
  708 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
   19 ( 0.00%)  	: _Bit_alloc_type(__a)
    3 ( 0.00%)  	{ }
    .           
    .           #if __cplusplus >= 201103L
    .           	// Not defaulted, to enforce noexcept(true) even when
    .           	// !is_nothrow_move_constructible<_Bit_alloc_type>.
    .           	_Bvector_impl(_Bvector_impl&& __x) noexcept
    .           	{ }
    .           
    .           	_Bvector_impl(_Bit_alloc_type&& __a, _Bvector_impl&& __x) noexcept
    .           	{ }
    .           #endif
    .           
    .           	_Bit_type*
   38 ( 0.00%)  	_M_end_addr() const _GLIBCXX_NOEXCEPT
  338 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
    .           	{
   22 ( 0.00%)  	  if (this->_M_end_of_storage)
    .           	  return 0;
    4 ( 0.00%)  	}
    .                 };
    .           
    .               public:
    .           
    .                 _Bit_alloc_type&
    .                 { return this->_M_impl; }
-- line 515 ----------------------------------------
-- line 523 ----------------------------------------
    .           
    .           #if __cplusplus >= 201103L
    .                 _Bvector_base() = default;
    .           #else
    .                 _Bvector_base() { }
    .           #endif
    .           
1,167 ( 0.05%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
   42 ( 0.00%)        : _M_impl(__a) { }
    .           
    .           #if __cplusplus >= 201103L
    .                 _Bvector_base(_Bvector_base&&) = default;
    .           
    .                 { }
    .           #endif
    .           
   19 ( 0.00%)        ~_Bvector_base()
2,874 ( 0.12%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
   21 ( 0.00%)        { this->_M_deallocate(); }
    .           
    .               protected:
    .                 _Bvector_impl _M_impl;
    .           
    .                 _Bit_pointer
   21 ( 0.00%)        _M_allocate(size_t __n)
  684 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
   27 ( 0.00%)        { return _Bit_alloc_traits::allocate(_M_impl, _S_nword(__n)); }
    .           
    .                 void
   19 ( 0.00%)        _M_deallocate()
2,524 ( 0.10%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .                 {
   11 ( 0.00%)  	if (_M_impl._M_start._M_p)
    .           	  {
   15 ( 0.00%)  	    const size_t __n = _M_impl._M_end_addr() - _M_impl._M_start._M_p;
   13 ( 0.00%)  	    _Bit_alloc_traits::deallocate(_M_impl,
    5 ( 0.00%)  					  _M_impl._M_end_of_storage - __n,
    .           					  __n);
    9 ( 0.00%)  	    _M_impl._M_reset();
    .           	  }
    3 ( 0.00%)        }
    .           
    .           #if __cplusplus >= 201103L
    .                 void
    .                 _M_move_data(_Bvector_base&& __x) noexcept
    .           #endif
    .           
    .                 static size_t
   38 ( 0.00%)        _S_nword(size_t __n)
  138 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
   10 ( 0.00%)        { return (__n + int(_S_word_bit) - 1) / int(_S_word_bit); }
    .               };
    .           
    .             /**
    .              *  @brief  A specialization of vector for booleans which offers fixed time
    .              *  access to individual elements in any order.
    .              *
    .              *  @ingroup sequences
    .              *
-- line 581 ----------------------------------------
-- line 639 ----------------------------------------
    .                 : _Base(__a) { }
    .           
    .           #if __cplusplus >= 201103L
    .                 explicit
    .                 : vector(__n, false, __a)
    .                 { }
    .           
   23 ( 0.00%)        vector(size_type __n, const bool& __value,
3,124 ( 0.13%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .           #else
    .                 explicit
    .                 vector(size_type __n, const bool& __value = bool(),
    .           #endif
   10 ( 0.00%)        : _Base(__a)
    .                 {
   10 ( 0.00%)  	_M_initialize(__n);
   12 ( 0.00%)  	_M_initialize_value(__value);
    4 ( 0.00%)        }
    .           
    .                 vector(const vector& __x)
    .                 {
    .           	_M_initialize(__x.size());
    .           	_M_copy_aligned(__x.begin(), __x.end(), begin());
    .                 }
    .           
-- line 666 ----------------------------------------
-- line 725 ----------------------------------------
    .           	: _Base(__a)
    .           	{
    .           	  // Check whether it's an integral type. If so, it's not an iterator.
    .           	  _M_initialize_dispatch(__first, __last, _Integral());
    .           	}
    .           #endif
    .           
   31 ( 0.00%)        ~vector() _GLIBCXX_NOEXCEPT { }
    .           
    .                 vector&
    .                 operator=(const vector& __x)
    .                 {
    .           	if (&__x == this)
    .           	  return *this;
    .           #if __cplusplus >= 201103L
    .           	if (_Bit_alloc_traits::_S_propagate_on_copy_assign())
-- line 741 ----------------------------------------
-- line 823 ----------------------------------------
    .           
    .           #if __cplusplus >= 201103L
    .                 void
    .                 assign(initializer_list<bool> __l)
    .                 { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }
    .           #endif
    .           
    .                 iterator
1,100 ( 0.05%)        begin() _GLIBCXX_NOEXCEPT
12,060 ( 0.50%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (44x)
1,408 ( 0.06%)        { return iterator(this->_M_impl._M_start._M_p, 0); }
    .           
    .                 const_iterator
    .                 begin() const _GLIBCXX_NOEXCEPT
    .                 { return const_iterator(this->_M_impl._M_start._M_p, 0); }
    .           
    .                 iterator
    .                 end() _GLIBCXX_NOEXCEPT
    .                 { return this->_M_impl._M_finish; }
-- line 840 ----------------------------------------
-- line 898 ----------------------------------------
    .                 { return size_type(const_iterator(this->_M_impl._M_end_addr(), 0)
    .           			 - begin()); }
    .           
    .                 _GLIBCXX_NODISCARD bool
    .                 empty() const _GLIBCXX_NOEXCEPT
    .                 { return begin() == end(); }
    .           
    .                 reference
1,100 ( 0.05%)        operator[](size_type __n)
2,028 ( 0.08%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (2x)
1,496 ( 0.06%)        { return begin()[__n]; }
    .           
    .                 const_reference
    .                 operator[](size_type __n) const
    .                 { return begin()[__n]; }
    .           
    .               protected:
    .                 void
    .                 _M_range_check(size_type __n) const
-- line 915 ----------------------------------------
-- line 1129 ----------------------------------------
    .           		      iterator __result)
    .                 {
    .           			 iterator(__q, 0));
    .                 }
    .           
    .                 void
   25 ( 0.00%)        _M_initialize(size_type __n)
1,517 ( 0.06%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .                 {
   10 ( 0.00%)  	if (__n)
    .           	  {
   12 ( 0.00%)  	    _Bit_pointer __q = this->_M_allocate(__n);
   15 ( 0.00%)  	    this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
    7 ( 0.00%)  	    this->_M_impl._M_start = __start;
   19 ( 0.00%)  	    this->_M_impl._M_finish = __start + difference_type(__n);
    .           	  }
   11 ( 0.00%)        }
    .           
    .                 void
   21 ( 0.00%)        _M_initialize_value(bool __x)
  299 ( 0.01%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .                 {
   13 ( 0.00%)  	if (_Bit_type* __p = this->_M_impl._M_start._M_p)
   16 ( 0.00%)  	  __builtin_memset(__p, __x ? ~0 : 0,
   12 ( 0.00%)  => ./string/../sysdeps/aarch64/memset.S:__GI_memset (1x)
   12 ( 0.00%)  			   (this->_M_impl._M_end_addr() - __p)
    .           			   * sizeof(_Bit_type));
    .                 }
    .           
    .                 void
    .                 _M_reallocate(size_type __n);
    .           
    .           #if __cplusplus >= 201103L
    .                 bool
-- line 1162 ----------------------------------------

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Ir             

-- line 71 ----------------------------------------
    .           
    .           #if __cplusplus >= 201103L
    .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
    .                 // 2103. propagate_on_container_move_assignment
    .           #endif
    .           
    .                 _GLIBCXX20_CONSTEXPR
   67 ( 0.00%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .           
    .                 _GLIBCXX20_CONSTEXPR
   67 ( 0.00%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .           
    .                 template<typename _Tp1>
    .           	_GLIBCXX20_CONSTEXPR
    .           
    .           #if __cplusplus <= 201703L
   67 ( 0.00%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .           
    .                 pointer
    .                 address(reference __x) const _GLIBCXX_NOEXCEPT
    .           
    .                 const_pointer
    .                 address(const_reference __x) const _GLIBCXX_NOEXCEPT
    .           #endif
    .           
    .                 // NB: __n is permitted to be 0.  The C++ standard says nothing
    .                 // about what the return value is when __n == 0.
    .                 _GLIBCXX_NODISCARD _Tp*
  756 ( 0.03%)        allocate(size_type __n, const void* = static_cast<const void*>(0))
  406 ( 0.02%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (1x)
    .                 {
    .           #if __cplusplus >= 201103L
    .           	 // _GLIBCXX_RESOLVE_LIB_DEFECTS
    .           	 static_assert(sizeof(_Tp) != 0, "cannot allocate incomplete types");
    .           #endif
    .           
  720 ( 0.03%)  	if (__builtin_expect(__n > this->_M_max_size(), false))
    .           	  {
    .           	    // _GLIBCXX_RESOLVE_LIB_DEFECTS
    .           	  }
    .           
    .           #if __cpp_aligned_new
    .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
    .           	  {
    .           	    return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), __al));
    .           	  }
    .           #endif
  678 ( 0.03%)  	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
2,370 ( 0.10%)  => ???:operator new(unsigned long)'2 (10x)
  108 ( 0.00%)        }
    .           
    .                 // __p is not permitted to be a null pointer.
    .                 void
  756 ( 0.03%)        deallocate(_Tp* __p, size_type __t __attribute__ ((__unused__)))
5,114 ( 0.21%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
    .                 {
    .           #if __cpp_aligned_new
    .           	if (alignof(_Tp) > __STDCPP_DEFAULT_NEW_ALIGNMENT__)
    .           	  {
    .           	    ::operator delete(__p,
    .           # if __cpp_sized_deallocation
    .           			      __t * sizeof(_Tp),
    .           # endif
    .           	    return;
    .           	  }
    .           #endif
  678 ( 0.03%)  	::operator delete(__p
6,231 ( 0.26%)  => ???:operator delete(void*, unsigned long) (36x)
    .           #if __cpp_sized_deallocation
    .           			  , __t * sizeof(_Tp)
    .           #endif
    .           			 );
   72 ( 0.00%)        }
    .           
    .           #if __cplusplus <= 201703L
    .                 size_type
    .                 max_size() const _GLIBCXX_USE_NOEXCEPT
    .                 { return _M_max_size(); }
    .           
    .           #if __cplusplus >= 201103L
    .                 template<typename _Up, typename... _Args>
    .           	void
  828 ( 0.03%)  	construct(_Up* __p, _Args&&... __args)
5,886 ( 0.24%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
    .           
    .                 template<typename _Up>
    .           	void
  680 ( 0.03%)  	destroy(_Up* __p)
1,562 ( 0.06%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (24x)
  192 ( 0.01%)  	{ __p->~_Up(); }
    .           #else
    .                 // _GLIBCXX_RESOLVE_LIB_DEFECTS
    .                 void
    .                 construct(pointer __p, const _Tp& __val)
    .                 { ::new((void *)__p) _Tp(__val); }
    .           
    .                 void
-- line 176 ----------------------------------------
-- line 189 ----------------------------------------
    .           	friend _GLIBCXX20_CONSTEXPR bool
    .           	_GLIBCXX_NOTHROW
    .           	{ return false; }
    .           #endif
    .           
    .               private:
    .                 _GLIBCXX_CONSTEXPR size_type
  684 ( 0.03%)        _M_max_size() const _GLIBCXX_USE_NOEXCEPT
  662 ( 0.03%)  => ./gmon/../gmon/mcount.c:_mcount@@GLIBC_2.18'2 (10x)
    .                 {
    .           #if __PTRDIFF_MAX__ < __SIZE_MAX__
    .           #else
    .           #endif
   72 ( 0.00%)        }
    .               };
    .           
    .           _GLIBCXX_END_NAMESPACE_VERSION
    .           } // namespace
    .           
    .           #endif

--------------------------------------------------------------------------------
The following files chosen for auto-annotation could not be found:
--------------------------------------------------------------------------------
  ./elf/../elf/dl-sysdep.c
  ./elf/../sysdeps/aarch64/dl-machine.h
  ./elf/../sysdeps/aarch64/dl-trampoline.S
  ./elf/../sysdeps/generic/dl-protected.h
  ./elf/../sysdeps/generic/ldsodefs.h
  ./elf/../sysdeps/nptl/dl-tls_init_tp.c
  ./elf/../sysdeps/posix/dl-fileid.h
  ./elf/./dl-find_object.h
  ./elf/./dl-map-segments.h
  ./elf/./elf/dl-cache.c
  ./elf/./elf/dl-deps.c
  ./elf/./elf/dl-environ.c
  ./elf/./elf/dl-error-skeleton.c
  ./elf/./elf/dl-find_object.c
  ./elf/./elf/dl-fini.c
  ./elf/./elf/dl-hwcaps.c
  ./elf/./elf/dl-init.c
  ./elf/./elf/dl-load.c
  ./elf/./elf/dl-lookup-direct.c
  ./elf/./elf/dl-lookup.c
  ./elf/./elf/dl-minimal-malloc.c
  ./elf/./elf/dl-minimal.c
  ./elf/./elf/dl-misc.c
  ./elf/./elf/dl-object.c
  ./elf/./elf/dl-profstub.c
  ./elf/./elf/dl-reloc.c
  ./elf/./elf/dl-runtime.c
  ./elf/./elf/dl-setup_hash.c
  ./elf/./elf/dl-sort-maps.c
  ./elf/./elf/dl-tunables.c
  ./elf/./elf/dl-tunables.h
  ./elf/./elf/dl-version.c
  ./elf/./elf/do-rel.h
  ./elf/./elf/get-dynamic-info.h
  ./elf/./elf/rtld.c
  ./elf/./get-dynamic-info.h
  ./gmon/../gmon/mcount.c
  ./gmon/../sysdeps/aarch64/sysdep.h
  ./gmon/./gmon/gmon.c
  ./iconv/./iconv/gconv_simple.c
  ./io/../sysdeps/unix/sysv/linux/fstatat64.c
  ./io/../sysdeps/unix/sysv/linux/open64_nocancel.c
  ./libio/./libio/fileops.c
  ./libio/./libio/genops.c
  ./libio/./libio/iofflush.c
  ./libio/./libio/iofwrite.c
  ./libio/./libio/libioP.h
  ./malloc/./malloc/arena.c
  ./malloc/./malloc/malloc.c
  ./misc/../sysdeps/unix/sysv/linux/mmap64.c
  ./posix/./posix/getopt.c
  ./setjmp/../sysdeps/aarch64/setjmp.S
  ./stdlib/../stdlib/strtol_l.c
  ./stdlib/./stdlib/cxa_atexit.c
  ./stdlib/./stdlib/exit.c
  ./stdlib/./stdlib/getenv.c
  ./stdlib/./stdlib/rand.c
  ./stdlib/./stdlib/random.c
  ./stdlib/./stdlib/random_r.c
  ./string/../sysdeps/aarch64/memcmp.S
  ./string/../sysdeps/aarch64/memset.S
  ./string/../sysdeps/aarch64/multiarch/../memcpy.S
  ./string/../sysdeps/aarch64/multiarch/../strlen.S
  ./string/../sysdeps/aarch64/multiarch/strlen_asimd.S
  ./string/../sysdeps/aarch64/strchr.S
  ./string/../sysdeps/aarch64/strcmp.S
  ./string/./string/strcspn.c
  ./wcsmbs/./wcsmbs/btowc.c
  ./wcsmbs/./wcsmbs/wctob.c
  ./wcsmbs/./wcsmbsload.h
  ./wctype/./wctype/wctype_l.c

--------------------------------------------------------------------------------
Ir               
--------------------------------------------------------------------------------
149,308 ( 6.16%)  events annotated

